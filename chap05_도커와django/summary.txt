도커를 활용한 django 실행
	: pyenv 를 활용한 파이썬 가상환경 구축
	: YAML 파일 개념
	: docker compose 를 활용해 웹 서비스를 실행

---------------------------------------------------------------------------------------------------------




갑자기 발생한 에러의 원인
	: https://tbmaster.tistory.com/132

noble, focal 같은거 >> 우분투 버전
	: 나는 noble ( 24.04 LTS )

내용 긴 파일 스크롤 하면서 보는 법 >> less 파일명
	: ↓ 또는 ↑ 키로 스크롤 가능하고, q 키를 사용하여 벗어난다. 	
	: 근데 뭐 어차피 PuTTy 설치했는데 그거쓰자 굳이 virtual box 그대로 쓰지 말고




apt 와 repository 
	: https://jjeongil.tistory.com/1682	
	: https://www.todayhumor.co.kr/board/view.php?table=computer&no=92067 << 3번째 댓글
	: apt Advanced Packaging Tool >> 패키지 관리(설치, 업데이트,제거) 툴
		: apt 가 설치 및 업데이트를 할 때, "repository" 에서 해당 패키지를 가져오게 된다. 

	: apt repository >> apt 로 설치당하는 패키지가 저장되있는 저장소.
		: ubuntu 기본 리파지토리 >> 4가지 컴포넌트(구성요소) 로 이루어짐
		    : basic 하다는점에서 "기본"인거지, 배포될 때부터 깔려있다는게 아님 주의
			1. main
			2. restricted 
			3. multiverse
			4. universe

		: /etc/apt/sources.list.d 의 ubuntu.sources (이전엔 sources.list . 형식은 같다 ) 에 repository가 정의되어진다
			: 정의 형식  >> [ deb || deb-src ] [ 리파지토리URL ] [우분투버전] 컴포넌트명
			    : deb >> (사전 컴파일된) 바이너리형식의 리포지토리 패키지. 일반적으로 사용.
			    : deb-src >> (원본) 소스코드형식의 리포지토리 패키지
			    : 컴포넌트 여러개 나열 가능(띄어쓰기로 구분하는거지 콤마는 안쓰는거 주의)

			   

			    : ex ) 
				: deb http://archive.ubuntu.com/ubuntu noble main restricted multiverse universe
			    	: deb http://archive.ubuntu.com/ubuntu noble-update main restricted multiverse universe << 구글링했을때 이거 한 글은 못봤는데 GPT는 (기본저장소 추가 후) 업데이트 저장소까지 추가하더라. 


	: ubuntu 에 repository 를 추가하는 법
	    : repository 를 추가한다 == apt 가 패키지를 가져올 수 있는 repository의 URL을 추가한다 
		sol1. add-apt-repository 명령어 사용
		    : add-apt-repository >>apt repository 설정을 쉽게 할 수 있데 해주는 툴
			:  sources.list 을 직접 편집하지 않아도 되게 해준다.
			: 이 패키지의 사용을 위해선 software-properties-common 패키지가 먼저 설치되어있어야됨
				: sudo apt-get install software-properties-common
			: 사용법 >> sudo add-apt-repository "sources.list에서의리파지토리정의형식" 

		sol2. 텍스트 편집기 사용 >> 직접 "[ deb || deb-src ] [ 리파지토리URL ] [우분투버전] 컴포넌트명" 입력



가상환경>> 독립된 개발환경.
	: 프로젝트를 진행하다 보면 여러 모듈을 설치하게 되는데, 각 모듈은 서로 의존성(dependency)을 가지는 경우가 많기 때문에 글로벌하게 모듈을 설치하게 되면 여러 프로젝트를 관리하기 어려운데, 이를  각각의 프로젝트에 필요한 모듈을 별도의 로컬 환경에 설치하는 방식으로 해결해주는 것이 가상환경
		: ex ) 프로젝트1에서는 A, B, 프로젝트2에서는 A, C라는 모듈을 사용하며 B는 A가 1.x 버전이고, C는 A가 2.x 버전이어야 사용 가능한 상황 >> 모듈을 글로벌 환경에 설치한다면 A는 1.x 또는 2.x 둘 중 하나만 설치할 수 있으므로 두 프로젝트를 모두 관리할 수 없다. 이때 가상환경을 통해 분리하여 설치하면 된다.

	: 파이썬 대표 가상환경
	    : 비표준
		1. virtualenv : 비표준 중 가장 많이 사용
		2. pyenv 

	    : 표준
		1. venv :  현재 기준으로 유일하게 표준 라이브러리에서 지원하는 가상환경 라이브러리. Python 3.3부터 사용가능


	: https://homubee.tistory.com/38



이번 실습 과정에서 이러쿵 저러쿵 우여곡절 많았는데 결론 >> 교재를 그대로 따라하지 않은 내가 ㅂㅅ이었다🙆‍♀️
	


tip 
	1. 이미지를 생성한다 == 이미지를 빌드한다
	2. 컨테이너를 배포한다 == 기타 설정 및 컨테이너 생성
	3. 어떤 프로그램을 foreground 로 실행한다 == 어떤 프로그램을 프로세스로 실행한다
		: foreground VS background
			daemon (=background) >> 백그라운드에서 실행하고, 제어를 셸로 즉시 반환한다.
			foregroud >> 프로세스를 앞단에서 실행하고, 프로세스가 종료될 때까지 제어를 유지한다




실습을 위한 패키지 및 라이브러리
	: pyenv >> 파이썬 버전 관리 도구
		: 여러 버전의 python 을 설치하고 사용할 수 있게 도와준다		

	: django >> 웹 프레임워크 라이브러리
		: python 기반 웹 프로젝트를 쉽게 만들게해준다
	: gunicorn >> 웹 서버 통신 라이브러리(WSGI)
		: django와 같은 프로그램과 nginx같은 웹서버를 중계해준다
	: psycopg2 >> PostGreSQL 활용을 위한 라이브러리
	: tree >> 리눅스 시스템서 파일 시스템 구조를 시각적으로 쉽게 보여주는 패키지
		: sudo apt install tree 로 설치
		: "tree 경로" 로 , 해당 경로 이하의 디렉터리 구조 파악 가능

	: curl 과 wget >> 웹 서버로부터 컨텐츠를 가져오는 패키지
		: 둘 다 기능이 고만고만한데 curl 이 좀 더 최근거임.
		: 빠르긴 wget 이 더 빠른데 curl 이 좀더 복잡한 다운로드를 지원

	: PyYAML PyYAML is YAML parser and emitter for python >> python 기반으로 YAML 파일을 쉽게 다루기 위한 라이브러리
		: Python 에서 YAML 파일을 파싱하거나, Python 객체를 YAML 파일로 내보내기 위한 라이브러리
		: 설치하기
			(1) 파이썬 가상환경에 접속 >> pyenv activate py3_11_6 
			(2) pip 명령어로 설치 >> pip install pyyaml
		
		: 잘 설치되었는지 확인하기
			(1) 파이썬 가상환경에서 파이썬 실행 >> (아직 pyenv active py3_11_6이 유효한 상태에서 ) python 입력		
			(2) yaml 라이브러리 불러오기 >> import yaml 
				: 별다른 오류 문구 출력 안됬음 설치 잘 되있는 것
			(3) 가상 환경 종료 >> source decativate


pyenv 관련 헷갈리는 명령어  >> 유독 목록(?) 관련 좀 명령어가 헷갈리게 작명되어있다
	(1) pyenv --version : pyenv 자체의 버전을 출력
	(2) pyenv install --list : pyenv로 설치 가능한 파이썬 버전 목록확인
	(3) pyenv versions : 설치된 모든 파이썬 버전과 가상 환경 목록을 표시
	(4) pyenv virtualenvs : 설치된 모든 가상환경정보 확인
	(5) pyenv version : 현재 사용 중인 파이썬 버전에 관련된 정보 표시


pyenv , python , virtualenv , pip 의 관계
     : 그러니까 pyenv 가 우선 설치되고, pyenv 로 원하는 버전의 python 설치하고, pyenv 로 해당 버전의 virtualenv 생성하고, 그 virtualenv 내에서 pip 로 원하는 파이썬 패키지 install 하여 관리하는거다 
	: pyenv >> 다양한 python 버전 설치 및 관리 + 가상환경 생성 도구  
		: pyenv 로 여러 python 패키지를 설치 가능하다.
		: pyenv virtualenv 명령어를 사용하여 virtualenv 즉 가상환경을 생성할 수 있다.

	: pip Package Installer for Python >> 파이썬 패키지 관리자. 파이썬 관련 패지지를 설치 및 관리하는 도구
		: python 패키지 설치 시,  자동적으로 pip 패키지도 함께 다운로드된다.





pyenv 설치하기
	step1. 본격 pyenv 설치 이전에 먼저 설치해야할것 >> sudo apt-get update; sudo apt-get install make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev
		: 수행하는데 E: unable to locate package 에러 나면 >> repository 에 대한 설정이 제대로 안되어있는것.
			: 리파지토리 정의 하기 >> add-apt-repository "deb http://archive.ubuntu.com/ubuntu noble main restricted multiverse universe" 
				: 완료되면 /etc/apt/sources.list 에 해당 리파지토리들에 대한 위치가 잡혀서, 해당 리파지토리에 저장된 패키지들을 호스트의 apt 가 잘 인식할 수 있게 된다


	step2. 본격 pyenv 설치 >> curl https://pyenv.run | bash 
		: 앞서 설치한 curl 패키지를 사용하여 request 하여 스크립트를 다운받고, 다운로드한 스크립트를 bash 셸에서 실행한다. 
			: pyenv 가 스크립트란 말이 아니라, pyenv 를 설치 및 설정하는 과정에서 스크립트가 다운로드 되고 사용된다는 거임
				: 스크립트 >>  프로그램이나 명령어의 집합. 특정 작업을 자동화하거나 일련의 명령어를 순차적으로 실행하기 위해 작성된 텍스트 파일.



	
	step3. 추가 환경 설정 >> 
		step(1) 홈 디렉터리에서 파일 목록 확인>>  ls -al 
			: 숨김 파일인 .bashrc 파일 확인 가능

		step(2) vim .bashrc 로 .bashrc 파일의 젤 끝에 다음 4줄 추가
			export PYENV_ROOT="$HOME/.pyenv"
			command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"
			eval "$(pyenv init -)"
			eval "$(pyenv virtualenv-init -)"

		step(3) 셸 재시작 >> exec $SHELL



	step4. 제대로 설치되었는지 확인 >> pyenv -v



설치된 pyenv 로 python 설치하기
	step1.  설치 가능한 python 버전 확인 >> pyenv install --list
	step2.  pyenv 로 python 설치 >> pyenv install 특정버전 
		: 말 그대로 3.11.6 과 같은 특정 버전이지, "python 3.11.6" 의 꼴이 아님
	step3. 잘 설치되었는지 확인 >> pyenv versions





가상환경 관련
	설치된 python으로 가상환경 생성하기 >> pyenv virtualenv [설치된파이썬의버전] [가상환경명]
	생성된 가상환경 목록 확인 >> pyenv versions 및 pyenv virtualenvs 
	가상환경 실행 >> pyenv activate [가상환경명]
		: 제대로 실행되면 이후 라인부터 프롬프트의 젤 앞에 "(가상환경명)" 이 추가된 꼴로 진행된다
			ex ) py3_11_6이라는 가상환경을 activate 시킨 경우 >> (py3_11_6) eevee@myserver01:~$


	가상환경에 ( python기반 ) 라이브러리 설치 >> pip install 라이브러리명
		: 물론 가상환경 실행한 상태에서 설치해야됨 !!
		: 실습에서 가상환경에 설치한 잔잔바리 라이브러리들 ) django, gunicorn, psycopg2-binary
		: 제대로 설치됬는지 확인하려면 
			step1. python 실행 >> python
			step2. 설치한 라이브러리 import >> import django 등 차례대로 입력
			step3. import 한 라이브러리 버전 확인 >> 라이브러리명.__version__ 해서 버전 날 자오는지 확인

	가상환경 종료 >> source deactivate 


	파이썬 실행하기 >>
		1. 파이썬을 깔아둔 가상환경 실행하기>> pyenv activate [가상환경명]
		2. 해당 파이썬 실행하기 >> python

	파이썬 종료하기 >> 
		1. 파이썬을 종료 >> quit( )
		2. 파이썬 실행을 위해 실행시켰던 가상환경 종료>> source deactivate


		
		




포트 포워딩 >> "외부아이피:포트번호n" 과 "내부아이피:포트번호m"을 연결해주는 기능
	: 포트 포워딩을 해주는 이유 - 여러가지가 있겠지만 실습에서는 "한 가상머신의 외부아이피" 하나 와 "포트번호"들의 조합으로 "해당 가상머신 내부의 프로세스"들에 접근 가능하게 하기 위함.  


가상화 환경에서 "게스트"와 "호스트"
	: 게스트 >> 호스트 위에서 실행되는 "컨테이너"
	: 호스트 >> 가상 환경을 제공하는 실제 물리적 하드웨어(서버나 시스템) 혹은 "가상 머신"


버추얼 박스에서의 포트 포워딩 설정
	: 도구 탭-NAT네트워크탭 에서 포트포워딩 클릭 후, 규칙 추가 가능
	: 규칙의 구성
		(1) 이름 >> 해당 규칙명
		(2) 프로토콜 >> 네트워크 통신에 사용되는 프로토콜 지정.  TCP 혹은 UDP.
		(3) 호스트 IP >> 이 규칙이 적용되는 호스트(VM)의 IP 주소.
			: 호스트 IP 를 특정하지 않으면(빈칸으로 냅두면) 모든 호스트에 대해 적용됨 
		(4) 호스트 포트 >> 호스트 시스템의 어떤 포트로 트래픽을 받을 건지 결정
		(5) 게스트 IP >> 포트 포워딩된 트래픽이 전달될 게스트(도커 컨테이너)의 IP 주소. 
		(6) 게스트 포트 >> 게스트의 어떤 포트로 트래픽을 전달할 건지 지정 

YAML YAML Ain't Markup Language 
	: 도커 컴포즈, 쿠버네티스에서 YAML 파일을 활용한다
	: YAML 파일 확장자는 .yml 혹은 .yaml
		: 두 개의 기능상 차이는 없음

	: 문법 >> 
		: 기본적으로 파이썬의 딕셔너리 자료형처럼 key:value 꼴
		: - >> 한 요소의 시작을 나타냄. ( 그러니까 -key : value 는 사실상 ..., {key: value}, ...  라는 거임 )
			: - 로시작하지 않는 줄은 (기존 요소의) 다음 요소로 추가됨. ( 그러니까 key : value 는 걍 ..., key: value, ...  라는 거임 )

		: 교재 실습의 예시
			apiVersion: v1
			kind: Pod
			metadata:
			  name: nginx
			spec:
			  containers:
			  - name: nginx
			    image: nginx:latest
			  - name: ubuntu
			    image: ubuntu:latest


			를 객체화 하면

			{'apiVersion': 'v1', 'kind': 'Pod', 'metadata': {'name': 'nginx'}, 'spec': {'containers': [{'name': 'nginx', 'image': 'nginx:latest'}, {'name': 'ubuntu', 'image': 'ubuntu:latest'}]}}



HTTP Upstream, Downstream  
	: stream >> 데이터의 흐름
		: Upstream >> 데이터가 위로 흐른다. 클라이언트 -> 서버의 방향.
		: Downstream >> 데이터가 아래로 흐른다. 서버 -> 클라이언트의 방향

	: https://westlife0615.tistory.com/265




django 실행을 위한 네트워크 설정 
	: 포트포워딩을 통해 호스트PC(=가상머신과 puTTy 등이 올라가는 실제물리적컴퓨터 !=puTTy)에서, "도커호스트IP" 와 "특정포트" 조합으로, 도커호스트(=가상머신)의 특정 프로세스에 접근 가능하게 함
		: 버츄얼 박스에서의 포트 포워딩 설정 내용
			(1) Rule2 >>  모든 호스트의 포트 8000으로 들어오는 트래픽을 게스트의 포트 8000으로 전달
				프로토콜 : TCP (걍 디폴트값 그대로)
				호스트 IP : 빈 칸 (걍 디폴트 값 그대로 ) 
				호스트 포트 : 8000
				게스트 IP : 10.0.2.4 
				게스트 포트 : 8000 

			(2) Rule3 >> 모든 호스트의 포트 80 으로 들어오는 트래픽을 게스트의 포트 80 으로 전달
				프로토콜 : TCP (걍 디폴트값 그대로)
				호스트 IP : 빈 칸 (걍 디폴트 값 그대로 ) 
				호스트 포트 : 80
				게스트 IP : 10.0.2.4 
				게스트 포트 : 80 


	: django >> 파이썬 기반 웹 사이트 전용 웹 프레임워크
		: 일단 교재 수준에서만 알아두고, 추후 nginx 다루는데도 나온다 싶으면 더 깊게 파보기
		: django 기본 명령어 >> django-admin 어쩌구
		: 새 django 프로젝트 생성 >>  django-admin startproject [프로젝트명]
			: django 는 ( 걍 리눅스가 아닌 ) 파이썬 기반이기 때문에 가상환경 실행 후(pyenv ativate) 생성해야된다 

			: settings.py 변경 >> ALLOWED_HOSTS = ['*'] 로
				: 모든 대상 대해 외부에서 접근 가능하도록 설정한 것


		 : django 의 마이그레이션 migration >>  애플리케이션(클래스 모델)의 변경사항을 데이터베이스에 반영하는 것
			: 장고는 ORM을 사용하고, models.py 같은 클래스로 DB 스키마를 생성 및 컨트롤(여러 테이블 생성 및 그에 대한 작업)
				
			: migration 관련 명령어
				: 명령어들을 보면 manage.py 라는 파일이 고정적으로 들어가있다
					: manage.py >> Django 프로젝트와 다양한 방법으로 상호작용하는 커맨드라인 유틸리티.
						: django-admin 과 동일한 명령어를 제공(=django 프로젝트를 활용할 수 있는 명령어를 제공)하는데, 해당 django 프로젝트의 settings.py 파일을 참조/반영한다. 
							: 보통 mange.py 명령어가 django-admin 명령어보다 선호된다.
							: 그러니까 ex ) 
								: django-admin runserver 명령어를 사용하면 Django 개발 서버가 시작되지만, 이 때 프로젝트의 데이터베이스 설정이나 다른 설정이 로드되지 않는다
								: python manage.py runserver를 사용하면 개발 서버가 시작되면서 settings.py에 정의된 프로젝트 설정이 모두 적용된다
						: https://velog.io/@mingming_eee/Django-day1

				1. 마이그레이션을 생성 >> python manage.py makemigrations [app_name]
					: 현재 스냅샷을 찍어두는 거라고 봄 됨
					: [app_name]생략 안 할 시  >> 해당 app에 대해서만 마이그레이션진행
						: 의도치 않은 마이그레이션을 생성시키고 싶지 않으면 [app_name]을 명시해라

 	되지 				: [app_name]생략시 >> 전체 app 에 대해 마이그레이션 진행
						: 프로젝트 생성 후 처음 하는 migrate 작업을 위한 마이그레이션을 생성할 때는 app_name을 "반드시" 생략



				2. 마이그레이션을 적용 >> python manage.py migrate [app_name] [migration_name]
					: 그러니까 찍어둔 스냅샷을 실제 db에 적용하는 명령어
					: [app_name]생략 안 할 시  >> 해당 app에 대해서만 db 에 반영
 	되지 				: [app_name]생략시 >> 전체 app에 대해 db 에 반영


					


		 : django 프로젝트 실행 >> python mange.py runserver [IP주소:포트번호]

			: django 개발 서버를 시작하여 특정 포트를 통해 접근할 수 있도록 함.

			: [ip주소:포트번호] >> 서버에 바인딩할 IP주소와 포트 번호 지정
				: IP주소 
					: 디폴트 >> 127.0.0.1
						: 이 값의 경우 외부 호스트의 접근이 허용되지 않는다 (로컬호스트)

					: 주로 0.0.0.0 값을 주고 사용한다
						: 0.0.0.0 == 모든 네트워크 인터페이스. 그러니까 (실제로 서버에 0.0.0.0을 바인딩하겠다는건 아니고) 서버가 모든 IP 주소에서 들어오는 요청을 수신하도록 설정한다. 

						: 로컬 || 외부 장치에서의 접근이 가능하다
							: runserver 명령어 뒤에는 0.0.0.0 으로 했었지만, 브라우저로는 0.0.0.0 으로 접근이 불가

							: 로컬장치(서버 올린 컴터) 에서의 브라우저로 애플리케이션에 접근 >> http://127.0.0.1:포트번호 혹은 http://localhost:포트번호

							: 외부 장치의 브라우저로 애플리케이션에 접근 >> http://같이공유하는WIFI아이피:포트번호 

		
					: runserver 뒤에는 실제로 서버가 실행되고 있는 컴퓨터에 할당된 IP 주소들 만 올 수 있다 >> 서버에 바인딩하고 싶은 IP를 입력한다고 쓸 수 있는건 아니다. 
						: 그냥 무턱대고 원하는 IP 쓰면 , Error: That IP address can't be assigned to. 라고 뜨고 실행이 안된다

						: 해당 서버에 사용 가능한 IP를 보기 위해선 걍 니 컴터에서 ipconfig 를 실행해봐라



				: 포트
					:  디폴트 >> 8000 

			: runserver는 개발/테스트 용으로만 쓰고, (보안상) 배포용으로 쓰지 않는다 
				: 주로 배포용으로는 Nginx , Gunicorn 을 쓴다.
				: https://velog.io/@gyuls/Django-runserver%EB%8A%94-%EC%99%9C-%EB%B0%B0%ED%8F%AC-%EB%95%8C-%EC%93%B0%EB%A9%B4-%EC%95%88%EB%90%A0%EA%B9%8C
		
		
		 : django 이미지 빌드 >> django 프로젝트를 컨테이너 이미지로 빌드하기
			: 이미지 생성 == 이미지 빌드
			: 절차 
				(1) 디렉터리 정리
					: 원본 프로젝트가 담긴 폴더(ex02)를 복붙해 새폴더(ex03) 생성 >> 해당 폴더에 이미지 빌드에 필요한 모든 파일 생성하게 될 것  

				(2) requirements.txt 파일 생성 및 작성
				     :  requirements.txt  >> 도커 이미지를 생성하기 위해 필요한 설치 파일 목록
					1. vim requirements.txt 하고 필요한 목록 작성
						: 실습에선 django==4.2.7
					2. 잘 써졌나 확인 cat requirements.txt

				(3) Dockerfile 파일 생성 및 작성
				    : Dockerfile >> 도커 이미지 파일을 생성하기 위해 필요한 명령어를 모아둔 파일
					: 파일의 확장자가 없고, 파일명이 대문자로 시작하는거 주의
					: 명령어라는게, (셸에서 쓰는) 리눅스 명령어가 아니라 (자체적인) dockerfile 명령어이다
					: 주요 Dockerfile 명령어 
						1. FROM >>  생성할 이미지의 베이스가 될 이미지
							: Dockerfile 작성 시 반드시 한 번 이상 입력해야됨
							: 베이스 이미지 >> Docker 이미지를 만들기 위한 시작점. python 같은 정말 기초적인 것에 대한 것.

						2. WORKDIR >>리눅스의 cd 명령어와 비슷한 명령어로, 해당 디렉터리로 이동할 떄 사용

						3. RUN >> 이미지를 생성하는 순간(만) 실행이 되는 리눅스 명령어
							: 주로 라이브러리 설치를 위해 활용

						4. CMD 혹은 ENTRYPOINT >> 생성된 이미지로부터 컨테이너를 생성할 경우, 최초 실행될 리눅스 명령어를 지정
							: CMD 는 컨테이너 생성 당시 명령어를 직접 지정할 경우 변경 가능하게 한 것이고, ENTRYPOINT 는 변경 불가능하게 한 것.
							: 할당가능한 값
								실행 파일 형식 값 >> 명령어를 JSON 배열로 작성.  ( [ "명령어", "옵션", "인자1", "인자2" ] 꼴로 입력하는거지, 마냥 띄어쓰기를 기준으로 하는게 아님 주의)  
									: 명령어가 셸을 거치지 않고 직접 실행되어, 명령어가 그대로 실행됨
									: "/bin/sh", "-c" 를 앞에 요소로 추가하면 셸 형식 값과 같은 효과를 낼 수 있음
									: ex ) CMD ["echo", "*"] == 실제로 "echo *"로 실행됨. ( 즉, 걍 '*' 이 출력됨) 


								셸 형식 값 >> [ ] 없이 단순 문자열로 입력  
									: 해당 명령어는 셸( '/bin/sh -c' )을 통해 실행되어, 셸의 기능을 사용 가능
									: ex ) CMD echo * == 실제로는 "/bin/sh -c 'echo *' "로 실행됨. (즉, 현재 디렉터리에 있는 모든 파일의 이름이 출력됨)

									





						5. EXPOSE >> 생성된 이미지로부터 컨테이너를 생성할 경우, 노출시킬 포트를 설정
						6. ADD >> 이미지에 파일을 추가
							: Dockerfile 이 위치한 디렉터리에서 파일을 가져옴

						7. COPY [호스트파일/폴더경로] [이미지파일/폴더경로]>> 호스트의해당경로에 존재하는 파일/폴더를, 이미지의 해당 경로에 복사

						: https://devlog-wjdrbs96.tistory.com/296

			
					1. vim Dockerfile 하고 필요한 명령어를 작성
						: 실습에서는 
						FROM python:3.11.6

						WORKDIR /usr/src/app

						COPY . .

						RUN python -m pip install --upgrade pip
						RUN pip install -r requirements.txt

						WORKDIR ./myapp
						CMD python manage.py runserver 0.0.0.0:8000
						EXPOSE 8000


							: 해석하면 
								: FROM python:3.11.6 >>우리가 생성할 이미지 파일의 베이스가 python:3.11.6 이라는 것
								: WORKDIR /usr/src/app >> /usr/src/app 로 이동하겠다는 것

								: COPY . . >> 호스트의 현재 경로에 존재하는 파일/폴더들을, 현재 위치한 폴더(/user/src/app)에 복사
								: CMD python manage.py runserver 0.0.0.0:8000
>> 컨테이너 실행시 실행될 명령어를 지정- 서버를, 모든 외부 호스트 접근 가능하게, 시작하게 함
								: EXPOSE 8000 >> 8000번 포트를 연다




					
				(4) 이미지 빌드
					: 작성한 Dockerfile 을 바탕으로 도커 이미지를 생성 >> docker image build [옵션] [인자]  [Dockerfile의위치경로] 

						: https://javacan.tistory.com/entry/docker-start-7-create-image-using-dockerfile

						: 실습에서는 docker image build . -t myweb01
							: . == 현재 디렉터리 
							: -t 혹은 -tag == 이미지 이름(+이미지 태그) 정하는 옵션
								: 이름에다 태그까지 명시 가능 >> myweb:1.0




		 : django 컨테이너 생성. 배포 >> 생성한 django 이미지로 컨테이너 실행
			: 컨테이너 배포 == 컨테이너 생성 및 기타 설정 
			: 걍 일반적인 이미지로 컨테이너 생성했던거랑 비슷하게 함 됨. 근데 이제 포트 포워딩을 곁들인.. 
			: 포트포워딩 하여 이미지를 컨테이너로 실행하기 >> run 할 때 옵션으로 -p [도커호스트포트]:[컨테이너포트] 를 추가적으로 줌 됨
				: 실습에서는 >>  docker container run -d -p 8000:8000 myweb01
					: -d == 백그라운드 실행. detached 모드. 
					: -p == 포트포워딩 
						8000:8000 >> 호스트의 8000 번 트래픽을 이 컨테이너의 8000 번 으로 보내겠다. 


		 : Nginx, django 연동 후 실행 >> 	
			: Nginx 컨테이너를 실행 후 gunicorn 을 활용해 Nginx 와 django 를 연동
			: 엔진엑스 Nginx >> 가볍고 성능 좋은 web server. 
				: https://phsun102.tistory.com/45
				: 왜 사용
					1. 정적 파일들을 처리하기 위해 사용
					2. Reverse Proxy Server 로 활용됨
						: 80 번 포트로 들어오는 내용을 3000, 4000 .. .등의 다른 포트로 분산시키기 가능
					3. 비동기 이벤트 구조를 기반으로 동작 (Event-Driven)
						: 이에 반해 Apache 는 쓰레드/프로세스 기반

					4. ssl 인증 처리 가능

				: 핵심 파일
					: 설정 파일 >> nginx.conf , default.conf
						: nginx의 설정 파일 문법 
							: 사용하는 문법이 spring boot 의 build.gradle 과 비슷해보이긴 해도 build.gradle 과는 다른, nginx 자체적인 문법을 사용한다
								: build.gradle 은 Groovy 또는 Kotlin 으로 작성됨
							: 주요 문법 요소
								1. 블록 block >> 중괄호 { } 를 단위로 정의되며, 가질 수 있는 블록의 이름(?)은 정해져있다( http, server ... )
									: 일부 블록의 경우 별칭을 사용 가능 
										ex ) upstream backendgroup1{  ... } 
										ex ) upstream backendgroup2{  ... } 
										ex ) upstream backendgroup3{  ... } 


								2. 디렉티브 Directive >> 블록 내부에 위히하는 단일 명령어로, 특정 설정을 지정하는데 사용됨
									ex )     
									server {
										listen       80;
										server_name  localhost;
									    }
									에서 listen 과 server_name 이 디렉티브
									


								3. 각 문장의 끝에는 세미콜론을 명시 
									: 중괄호 다음 명시가 아니라 중괄호 내부의 문장 뒤에 ; 를 명시하는 것

						: nginx.conf VS default.conf >> default.conf 가 서버에 한정된 설정 파일. nginx.conf 가 포괄적인 설정 파일 
							: nginx.conf 에서 default.conf 를 include 하여 사용가능하므로 되도록 서버관련 설정은 default.conf 로 분리하여 관리하기 용이하게 하자

						: nginx.conf >> nginx 의 기본 설정 파일 
							: 다음의 내용이 정의됨 
								error_log >>  nginx의 에러로그가 쌓이는 경로
								pid  >>  nginx의 프로세스 아이디 (pid)가 저장되는 경로
								worker_connections  >>   Worker Process가 동시에 처리할 수 있는 접속자의 수를 나타낸다. 기본은 1024.
								include >> 어떤 파일을 포함시킬것인지.
									  include      /etc/nginx/conf.d/*.conf; >> /etc/nginx/conf.d에 .conf로 끝나는 파일들을 포함시켜 가져오겠다
								default_type >> 웹서버의 기본 Content-Type
								log_format >> 로그 형식을 지정
								access_log >>  접속 로그가 쌓이는 경로
								keepalive_timeout >> 클라이언트에서 연결이 유지될 시간을 정의

						: default.conf >>  (nginx.conf 의 http 블럭에서 include 하여 사용하는) 서버 설정 파일. 
							: default2.conf, default3.conf 등 여러 개의 파일을 추가하여 서버관련 설정을 추가로 만들 수 있다.
							: 다음의 내용이 정의됨 

								upstream >> nginx 가 받은 요청을 넘길 서버 그룹을 정의하는 블럭	
									: 그러니까 nginx 는 로드밸런싱역할도 수행하는데, 트래픽을 받게될 그룹을 정의하는 것.
										; AWS ELB 로 치면 target group 정의
									: 실제로 로드밸런싱을 구현하려면, 이 upstream 을 통해 target group 을 정의한 후 server 블록 내부의 location 블록의 proxy_pass 디렉티브의 값으로 해당 upstream그룹의 별칭을 주면 된다.
									: 이름이 upstream 인 이유는 클라이언트->서버쪽 방향의 트래픽에 대해 정의하는거니까
									: upstream 블록 내부에는 여러 "서버:포트"들을 정의 가능하고, 정의된 순서대로 라운드 로빈 방식으로 동작하게 된다.
										: 그러니까 upstream backendgroup1{
											server www.aaa.com:80;
											server www.bbb.com:80;
											server www.ccc.com:80;
										}
										와 같이 정의되어있는데 요청이 들어오면 차례대로 www.aaa.com:80, www.bbb.com:80 , www.ccc.com:80 로 트래픽을 분산시킨다

									: 로드밸런싱 가중치를 의미하는 weight 를 줄 수도, 안 줄 수도 있다
										: 1~10 정도의 값 주는 듯

									: backup을 표시하면 백업 전용 서버로 추가 가능 
										: 그러니까 앞에 정의된 모든 서버가 다운된 경우에만 트래픽을 받는 서버를 등록 가능
										ex) server www.ccc.com:80 backup; 과 같이 걍 뒤에 backup 이라는 단어만 추가하면 됨

									: 내부에 정의 가능한 디렉티브 
										1. server >> 어떤 IP와 포트를 그룹으로 포함시킬건지 지정

									: 형식 
										upstream 업스트림그룹별칭{
											server 서버IP1:포트1 weight=값1;
											server 서버IP2:포트2 weight=값2;
											.
											.
											.

										}

									: https://velog.io/@odh0112/Nginx-HTTP-%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%8B%B1
									


								server >> 특정 서버와 포트에 대해 어떤 action을 취할지 설정
									: 내부에 정의 가능한 디렉티브
										1. listen >> 포트 지정
										2. server_name >> 호스트 이름을 지정


									: 내부에 정의 가능한 그룹
										1. location >> 클라이언트가 요청한 path 에 따라, 해당 요청을 어떻게 처리할지 결정
											: location 뒤에 명시하는 uri 는 "/어쩌구"의 형태로 쓰이지, "어쩌구"의 형태로 쓰이지 않는다.
											: nginx 에서 reverse proxy 정의하는 것.. 
											: AWS 의 ELB의 리스너 규칙 정의와 비슷한데 포트 번호는 없는 ... (위에 listen 디렉티브로 따로 정해져있음)
											: 종류 <-- 정규표현식비슷한 문자를 사용하여 표현됨
											    : 적은 순서대로 우선순위가 높다
												1. =  >> exactly . 완전히 일치해야 만족
												2. ^~  >> priority prefix match. 우선 순위 부여 앞부분 일치. (해당 uri로 시작하기만 하면 만족)
													: 이름이 priority 인건, 기능은 걍  prefix match 랑 같은데 우선순위가 높은 얘라서 그런거임
												3. ~ >> regex match with sesitive case. 대소문자를 구분하여 일치

												4. *~ >> regex match with insesitive case. 대소문자를 구분하지않는 일치
												5.  >> prefix match.  앞부분 일치
													: 별다른 정규식 표현을 쓰지 않은거임


											: 내부에 정의가능한 디렉티브
												1. proxy_pass >> 어떤 IP, 포트로 라우팅할지 설정 
													: 인자 >>  IP주소:포트명
													: tip >> http://[정의한upstream그룹별칭]  을 하면 로드밸런싱의 구현이 가능

									: https://icerabbit.tistory.com/116





			: Nginx 컨테이너 배포(=설정 및 생성) 절차 
				(1) 디렉터리 정리 >> Nginx 전용 디렉터리를 새로 생성 
					: mkdir ex04
				(2) Dockerfile 파일 생성 및 작성 >> 
					: 실습에서는 
						FROM nginx:1.25.3
						CMD ["nginx", "-g", "daemon off;"]
					  와 같이 정의

					: 컨테이너를 활용해 Nginx 를 실행할 때는 daemon off 옵션을 명시해 foreground 로 실행해줘야된다.
					    : 왜 ? >> 아무런 옵션을 명시하지 않으면 Nginx 는 데몬 모드로 실행되고, 주 프로세스가 백그라운드로 전환되면서 Docker 컨테이너의 주 프로세스가 종료된 것으로 간주되어 해당 컨테이너가 즉시 종료된다.
						: Docker 컨테이너는 일반적으로 하나의 주 프로세스(main process)를 실행하기 위해 설계되었음
							: main process 가 종료되면 컨테이너도 종료됨 
						: Nginx 와 같은 서버는 기본적으로 daemon( 백그라운드 ) 모드 로 실행됨. 
						

				(3) 이미지 빌드 >> docker image build . -t mynigix01
					: 걍 django 이미지를 빌드하는 것과 존똑

				(4) 컨테이너 실행 >> docker container run -p 80:80 -d mynginx01
					: django 컨테이너 실행하는 것과 존똑인데 포트포워딩하는 포트 번호만 좀 다르게 
					: 웹 브라우저로 127.0.0.1 접속시 성공적으로 실행됨 확인 가능

		
			: Nginx 컨테이너 내부 설정 파일 확인 
				(1) 컨테이너 내부 접속>> docker container exec -it nginx컨테이너명 /bin/bash
				(2) 파일 확인 >> 		
					1. cd /etc/nginx/conf.d/
					2. ls >> default.conf 파일 있는것 확인 가능
					3. cat default.conf >> 뭔 내용있나 확인
				(3) 컨테이너 내부 접속 빠져나옴 >> exit 
				(4) 실행중인 컨테이너 모두 정지 >> docker container stop 컨테이너명



			: 구니콘 gunicorn Green Unicorn>> WSGI 중 하나로, python 웹 어플리케이션의 높은 트래픽을 쉽게 처리할 수 있는 가볍고 안정적인 서버
				: Django, Flask 등등의 파이썬 웹프레임워크랑 같이 사용되는 기술
				: WSGI WebSever Gateway Interface >> 파이썬 애플리케이션이 웹서버와 통신하기 위한 인터페이스
					: 대표적으로 gunicorn 과 uWSGI 가 있다
					: 왜 쓰는가? >> Django 나 Flask 자체적인 웹 서버는 보안/성능적으로 좋지 않아 배포에는 적합하지 않아 배포 시에는 따로 서버를 구현하고, 이를 gunicorn 으로 연결해 사용하게 됨

				: https://velog.io/@ggydo59/gnuicorn-gunicorn%EC%9D%B4%EB%9E%80-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C

			: 구니콘을 통한 연동 절차 << gunicorn 으로 앞서 생성한 django 프로젝트와 nginx 를 연동. 앞서 생성한 django 이미지를 수정.
				(1) django 디렉터리 정리 >> 앞서 생성한 프로젝트의 원본을 유지하면서 새 프로젝트를 생성하기 위해 새 폴더 파고 거기에 복사하여 진행
					1.  (work/ch05 아래에) 썡 새 디렉터리인 ex05를 정의 >> mkdir ex05 
					2. django실습디렉터리(ex03)를 ex05로 복사>> cp -r ex03 ex05 
						: -r 옵션 >> (단순 파일수준이아닌) 디렉터리 수준으로 복사
							: recursive 의 약자.
						
					3. 복사한 디렉터리명을 (가독성 높이기위해) 수정 >>  mv ex03 myDjango02

					4.  django 프로젝트 수정
						(1) 설치파일목록(requirements.txt) 에 구니콘 추가>> vim requirements.txt  하고 젤 끝에 gunicorn 20.1.0 추가
						(2) Dockerfile 의 CMD문 수정 >> vim Dockerfile 하고 기존 CMD문 (python manage.py runserver 0.0.0.0:8000) 삭제 후  gunicorn --bind 0.0.0.0:8000 myapp.wsgi:application 을 추가
							: EXPOSE 8000 과 CMD gunicorn --bind 0.0.0.0:8000 myapp.wsgi:application
								: EXPOSE 8000 >> 8000번 포트를 사용함을 문서화/기록 하는 것이 목적. 실질적 효력은 없음. 
								:  CMD gunicorn --bind 0.0.0.0:8000 myapp.wsgi:application >> 실질적으로 해당 애플리케이션이 (gunicorn 을 통해) 8000번 포트에서 실행되게 함.  




				(2) 수정한 django 이미지 빌드 >>  docker image build . -t myweb02


				(3) Nginx 디렉터리 정리 >> 마찬가지로 앞서 생성한 프로젝트의 원본을 유지하면서 새 프로젝트를 생성하기 위해 새 폴더 파고 거기에 복사하여 진행
					1.   Nginx실습디렉터리(ex04)를 (앞서 생성한 디렉터리인)ex05로 복사>> cp -r ex04 ex05 
						
					2. 복사한 디렉터리명을 (가독성 높이기위해) 수정 >>  mv ex04 myNginx02

					3. Nginx 프로젝트 수정
						(1) 다음을 내용으로하는 defalut.conf 추가 >> myNginx02 아래에서 바로 vim default.conf
							upstream myweb{
							    server djangotest:8000;
							}

							server{
							    listen 80;
							    server_name localhost;
							    location /{
							        proxy_pass http://myweb;
							    }
							}

							: 의미 >> 80번 포트로 받은 요청을 djangotest 라는 이름의 컨테이너의 80번 포트로 전달하겠다. 라우팅 시키겠다. 
								: 그러니까 upstream 으로 target group 정의하고 server 로 로드밸런서의 listener 정의한 것	
					
						


						(2) 다음을 내용으로 (복사되있던) Dockerfile 수정 >>  vim Dockerfile

							FROM nginx:1.25.3
							RUN rm /etc/nginx/conf.d/default.conf
							COPY default.conf /etc/ngnix/conf.d/
							CMD ["nginx", "-g", "daemon off;"]

							: 의미 >> 
								FROM nginx:1.25.3 >> nginx:1.25.3 을 DockerHub에서 가져와 base image 로 사용한다. 
									: nginx 이미지는 기본적으로 Nginx 웹 서버를 포함한다 

								RUN rm /etc/nginx/conf.d/default.conf >> 해당 이미지를 생성할 때 Nginx 의 기본설정 파일인 default.conf 를 삭제한다.
 

								COPY default.conf /etc/ngnix/conf.d/ >> 기존 nginx:1.25.3 의 default.conf 가 있던 자리에 직접 작성한 default.conf 를 배치시킨다

								CMD ["nginx", "-g", "daemon off;"] >> 생성된 이미지를 통해 컨테이너를 생성할 때마다  Nginx가 foreground 에서 실행되게 한다.

								

				(4) Nginx 이미지 빌드 >> docker image build . -t mynginx-2
				(5) 컨테이너 실행 
				    : 구현 flow 
					1. 웹브라우저의 주소창에 127.0.0.1:80 입력
					2. 포트포워딩 기능을 통해 10.0.2.4:80 으로 트래픽이 전달됨( ip 가 10.0.2.4인 도커 호스트의 80번 포트로 트래픽이 전달됨 ). 
					3. nginxtest 컨테이너를 통과 
					4. djangotest 컨테이너에 접속하여 django 서비스를 활용

				    : 실습 도안을 보면 gunicorn 이 djangotest 컨테이너 내부에 있는 것을 볼 수 있음. (Nginxtest 컨테이너가 아닌 djangotest 컨테이너의 내부에 있는것은) Dockefile 내부에 gunicorn을 명시한 쪽이 djangotest 였기 떄문. 그리고 gunicorn 은 nginx 나 django 와는 다르게 이미지화 시켜 실행된 컨테이너가 아니라 단순 import 된 라이브러리임. 

				    : 실습 절차
					1. 네트워크 구성
						(1) 브리지 생성 >> docker network create mynetwork02 
							: mynetwork02 를 name 으로하는 새로운 네트워크 생성. 이 네트워크 위에 컨테이너 생성할거임
								: 굳이 기존 bridge 네트워크 사용안하고, 새로운 사용자정의 네트워크 생성한 이유 >> 서브넷 만드는 이유와 비슷. 보안, 격리, 고정 IP 주소 및 DNS 이름 사용(사용자 정의 네트워크를 사용하면 특정 컨테이너에 고정 IP 주소를 할당할 수 있음), 확장성 및 관리 용이성 등을 제공하기 때문

						(2) 네트워크 목록 확인 >> docker network ls 
						

					2. 생성한 네트워크(mynetwork02) 상에서 앞서 빌드한 이미지들(myweb02, mynginx02 )로 컨테이너 실행
						(1) mynetwork2 상에서,  커스텀한 django이미지 (myweb02) 를 바탕으로 컨테이너 (djangotest) 생성 및 실행>> docker container run -d --name djangotest --network mynetwork02 myweb02
							: (docker container ls 했을때) 정상적으로 실행된 경우,  PORTS 부분이 8000/TCP 로 뜨는데 이는 Dockerfile 의 CMD 부분에 gunicorn --bind 0.0.0.0:8000 myapp.wsgi:application 을 명시했기 때문


						(2) mynetwork2 상에서 호스트의 80번 포트와 컨테이너의 80번 포트를 연결하여 ,  커스텀한 nginx (mynginx02) 를 바탕으로 컨테이너 (nginxtest ) 생성 및 실행>> docker container run -d --name nginxtst --network mynetwork02 -p 80:80 mynginx02
							: 왜그런진 모르갰지만 직접 컨테이너 생성해보면 default.conf 가 COPY가 되있지 않아서 직접 생성한 후 reload 해줘야됬음.
								1. 컨테이너 내부 접속 >> docker exec -it nginxtest /bin/bash

								2. default.conf 를 직접 생성 >> 
cat > /etc/nginx/conf.d/default.conf <<EOF
upstream myweb {
    server djangotest:8000;
}

server {
    listen 80;
    server_name localhost;

    location / {
        proxy_pass http://myweb;
    }
}
EOF

								3. Nginx 재시작>> nginx -s reload

							: (docker container ls 했을때) 정상적으로 실행된 경우,  PORTS 부분이 0.0.0.0:80->80/TCP (호스트의 모든 IP 주소에서 접근 가능한 포트 80이 컨테이너의 포트 80에 매핑되었음)로 뜨는데 이는 컨테이너 생성할 때 -p 옵션으로 80:80 포트포워딩을 시켰기 때문



						(3) 127.0.0.1:80 접속해보기 >> 잘 됨

