우분투 관련
	sudo >>SUperuser DO. 현재 사용자 권한이 어케됬건 root 권한으로 (sudo 뒤의) 명령어를 실행시킨다.
	apt >>Advanced Package Tool. 우분투에서 쓰이는 데비안 계열의 패키지를 관리하는데 쓰이는 도구
		: 응용프로그램 설치 삭제 업데이트 등의 작업을 하는데 사용된다



HTTP 특성
	1. connectionless >> response 끝나면 연결 바로 끊김
	2. stateless >> 이전에 통신했던 내용 저장 따로 안해둔다. 


무결성>> 데이터의 정확성, 일관성, 유효성이 유지되는 것


암호화 종류
    (1) 양방향. 복호화 가능. >> 원본 데이터를 복호화할 수 있어야 하는 상황, 예를 들어 안전한 정보 전송이 필요한 경우에 적합
	: https://velog.io/@480/RSA-%EC%95%94%ED%98%B8%ED%99%94-3%EB%B6%84-%EB%A7%8C%EC%97%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0

	1. 대칭키 암호화 : 하나의 키로 암호화, 복호화.
		: 대표적으론 AES , HMAC , HS256 
			: HS256 >>  HMAC + SHA256 . 
		: 보안측면에선 비대칭보다 딸린다 >> 어쨌뜬 키를 발급한 대상이 상대에게 한 번 이상 키를 넘겨줘야되니까. 

******2. 비대칭키 암호화: 각각 다른 키로 암호화, 복호화
		: 대표적으론 RSA
			: RSA라는 이름에 별 의미는 없다. 이 암호화 기법을 만든 수학자 3명의 이름을 따온것이다.

		: how it works >>  
			(1) 데이터를 받게 되는 쪽에서, 데이터를 주는 쪽에게 자물쇠와 해당 자물쇠를 잠글 키를 준다. 이때 키는 자물쇠를 잠글 수만 있고, 열 수는 없는 키이다.
			(2) 데이터를 주는 쪽에서 해당 자물쇠와 키로 보낼 데이터를 잠궈서 데이터를 전송한다
			(3) 데이터를 받는 쪽에서 자신이 가지고 있는 해당 자물쇠를 열 수 있는 키로 해당 자물쇠를 열어서 데이터를 확인한다. 	
				: 그러니까 복호화 가능한 키는, 데이터를 받는 쪽에서 항상 자신만 가지고 있던 것이다.
		: 공개되는 키를 public key, 비공개인 키를 private key 라고 한다.
			: public key , private key 개념에서 public 과 private 의 기준은 복호화 역할이냐 암호화 역할이냐 따라 정해지는게 아니라 공개냐 비공개냐에 따라 결정되는거다. 그리고 둘 중 한쪽은 무조건 암호화, 다른 쪽은 무조건 복호화 역할을 수행해야된다

    (2) 단방향. 해싱. 복호화 불가. >> 위조만 판단하면 되고,  민감한 정보를 포함해야하는 상황. ( ex- 회원가입시 db에 password 를 저장할 때 해싱하여 저장하여 개발자조차도 알 수 없게 한다 && 로그인 할 때 입력된 password 값을 db에 암호화되어 저장된 password 값과 비교하기 위해  입력된 password 값도 해싱하여 두 값이 같은지 판단한다. )
	: https://porolog.tistory.com/m/52
	: 대표적으론 SHA256
		: Secure Hash Algorithm 256 >>  입력된 데이터를 256비트 길이의 해시값으로 변환
			:  데이터의 무결성을 확인하는데 적합하며, 원본 데이터를 추론할 수 없는 고유한 해시값을 제공(산출되는 해시값은 원래 데이터에 대한 정보를 전혀 가지지 않는다)



spring security 에서의 암호화 >> 단방향 양방향 모두 사용된다.
	: 회원 가입을 할 때는 비밀번호를 저장하기 위해 SHA256 과 같은 단방향 암호화 알고리즘을 사용하여 데이터베이스에 비밀번호를 암호화된 형태로 저장시키고 
		: 개발자조차도 회원의 비밀번호 알 수 없다
		: 무결성 확인만 할 수 있고 값은 알 수 없기에 비밀번호를 까먹었을 때 원래 비밀번호를 알려주는게 아니라 아예 비번을 새로 파게 하는거다

	: 로그인 할 때는 클라이언트가 입력한 비밀번호를 SHA256으로 암호화하여 그 값을  데이터베이스에 저장한 암호화된 비밀번호와 비교하여 인증을 하고

	: 로그인 성공 시(비밀번호가 동일한 게 확인된 이후에는) jwt 토큰을 서버가 클라이언트에게 발급해주는데, 이때 signature 부분은 header 와 payload 를 base64 인코딩 한 값을  secret key로 HS256 과 같은 양방향 암호화 알고리즘을 사용하여 생성된다
		: 주의해야할 점은 jwt 토큰의 payload 자체는 아주 해독하기 쉬운 base64 인코딩되기 떄문에 비밀번호와 같은 민감한 정보를 담아서 보내면 안된다. 주로 username 정도만 payload 에 담아서 보낸다

	: 이후 인증된 클라이언트의 요청인지 확인하기 위해 클라이언트의 헤더 부분에 있는 jwt 토큰을 서버에 저장된 secret key 로 복호화하여 판단한다
		: 헷갈리지 말아야할 것은 HS256 은 "양방향" 이기 때문에 따로 복호화 전용 키가 있진 않고, 앞서 암호화 하는데 사용하였던 secret key 로 또 복호화 하는 것이다.




(디지털) 서명 >>데이터의 무결성을 증명하는 인증수단. (이 데이터는 해커로부터 온 것이 아니라 정상적으로 보내진 데이터다)


서명되었다 >> 해당데이터에 인증수단을 내장하게했다.


SSL Secure Sockets Layer 보안 소켓 계층, TLS  Transport Layer Security >> 암포화 기반 인터넷 보안 프로토콜.
	: 특징
		1. 핸드셰이크라는 인증 프로세스를 도입해 두 장치(클라이언트, 서버)의 ID 를 확인 
		2. 데이터에 디지털 서명하여 데이터 무결성 제공
		3. RSA 와 AES 섞어쓴다.
	: SSL 이 업데이트 한게 TLS  이다. SSL은 현재 사용 중인 TLS 암호화의 전신
	: SSL/TLS를 사용하는 웹사이트는 "HTTP" 대신 "HTTPS" 쓴다.

SSL 인증서 >> 서버의 신원을 증명하는 신분증
	: SSL/TLS 인증서 가 있는 웹사이트에서만 SSL 프로토콜의 사용이 가능하다.
	: 그러니까 클라이언트가 올바른 서버와 통신하고 있는지 확인하는 용도의 파일. 중간에 요청 뺐어서 제3의 서버로 요청을 보내게 하는 DNS 스푸핑 같은걸 막는다.
	: public key 와 private key (비공개) 를 포함한다.
	: https://aws-hyoh.tistory.com/59



CA >>  SSL 보안 인증서를 발급 및 인증하는 기관"들"
	: https://babbab2.tistory.com/5
	: 개인적으로도 SSL 인증서를 발급할 수 있지만, 그 인증서를 인증해 줄 기관이 있어야 신뢰 가능하기에 어떤 기관을 중간에 껴야 실질적인 SSL 인증서의 기능을 하는 인증서의 발급이 가능
	: certificate authority 의 약자	
	: ( 인증서 발급 주문 넣는 회사와는 별개로) CA 는 자체적으로 public key 와 private key 를 가진다.
		: private key 누설되면 그 CA 기관은 ㅈ되는거다


	: certifacate chain . chain of trust . >> 
		: 인증기관이 띡 하나만 존재하면, 해당 인증기관의 private key 만 털면 되니까 위험하다. 그래선지 2~3계층 구조로 이뤄져있다. 
		: SSL 인증서는 n개의 intermediate CA 에서 n 번 검증을 받은 뒤, 최종적으로 Root CA 에게 검증을 받고, Root CA 는 스스로를 검증하는 방식으로 검증된다.


		1. Root CA : 모두가 신뢰하기로 합의한 최상위 인증기관
			: 자체 서명 인증서를 보유한다 << 그러니까 얘 자기자신은 스스로 인증해준다는것. 위에 누가 더 없으니까
			: 루트 CA의 인증서"들"은 브라우저나 운영 체제에 미리 설치되어 있다. 그리고 이 목록은 주기적으로 업데이트 된다. 만약 해당 CA 리스트에 없는 
			: intermediate CA 처럼 root CA 기관도 여러개 존재하고, 인증 과정에 여러개 사용 가능하다

		2. Intermediate CA: 중간 기관(들) 
			: root ca 로부터 인증서를 발급받는다
			: 사용자에게 인증서를 발급해줄 수 있다
			: 여러개의 중간 기관이 존재할 수 있다.

		3. End-entity Certificate : 최종 엔티티 인증서
			: 개발자가 구입하게 되는 SSL 인증서. 
			


	: SSL 인증서 발급 절차
		1. 회사가 CA에게 인증서 발급에 필요한 정보( domain 등과 같은 사이트 정보와  public key )와 함ㄲㅔ 인증서 발급 요청
		2. CA 가 해당 사이트가 안전하다 판단하면 OK 함. 그리고 인증서 제작함
			step1. "회사"가 제출했던 public key 를 SHA-256 등으로 해시하여 인증서에 "finger print "로 등록
			step2. 앞서 등록한 "finger print" 를 "CA"의 private key 로 암호화하여 인증서에 "signature" 로 등록

		3. 회사에게 발급한 인증서 줌


	: 발급받은 SSL 인증서를 이용한 인증 및 통신 절차
		: 운영체제나 브라우저들은 미리 CA 리스트를 포함하고 있다.
			: CA 리스트 >> 공인 인증된 Root CA 기관들에 대한 리스트로, 그들의 "public key" 정보도 포함한다. 
			: 때문에 매번 직접 찾아가진 않아도 된다
			: CA 리스트는 주기적 업뎃 된다

		1. 클라이언트가 해당 서버에 접속하려고 시도
		2. 서버가 CA 에서 발급받은 인증서를 클라이언트에게 전달
		3. 클라이언트는 받은 인증서를 검증
			step1. 해당 인증서가 클라이언트 자신이 가진 CA 리스트에 있는 기관에서 발급받은 것인지 확인
			step2. 클라이언트는 CA 리스트에 저장되있는 해당 CA 기관의 public key 로 서명부분을 복호화 한다.
				: public key , private key 개념에서 public 과 private 의 기준은 복호화 역할이냐 암호화 역할이냐 따라 정해지는게 아니라 공개냐 비공개냐에 따라 결정되는거다. 그리고 둘 중 한쪽은 무조건 암호화, 다른 쪽은 무조건 복호화 역할을 수행해야된다

			step3. 클라이언트는 복호화한 signature 부분의 내용과 인증서에 기재된 public key 부분이 일치하는지 확인한다. 일치하면 검증된거다.
				; 앞서 인증서 발급할 때 signature 부분에 해당 회사의 public key 를 해싱한 거라서 그런거다


		4. 인증서를 검증에 성공시 클라이언트는 해당 서버를 신뢰할 수 있는 서버로 간주한다
		5. 클라이언트는 서버와 TSL 암호화 통신을 시작하기 위해 "handshake" 를 한다. 



TSL 의 handshake >> 실제 데이터를 주고 받기 전, 서버와 클라이언트가 서로 악수를 하며 연결할 수 있는지 상태를 살피는 것. TSL 암호화 통신에 사용할 대칭키를 클라이언트 측에서 서버 측으로 넘겨주는 과정
	: https://babbab2.tistory.com/7>> 추후 계속.



---------------------------------------------------------------------------------------------------------------

--도커 설치하기--


사전준비
	1. 도커 리포지토리 와 통신할 수 있는 환경 설정
		:  도커 리포지토리 >> 도커를 설치하기 위해 필요
		step1.  apt 패키지 인덱스를 업데이트 >>sudo apt-get update
		step2.  apt가 HTTPS에서 리파지토리를 사용할 수 있게 하는데 필요한 패키지를 설치 >>sudo apt-get install ca-certificates curl gnupg lsb-release
			: ca-certificates >> CA 목록 패키지

			: curl >>  Client URL. 클라이언트에서 url 을 사용해서 서버와 데이터를 송수신 하는걸 가능하게하는 명령어 툴.
				: 다양한 프로토콜(HTTP , HTTPS , TELNET , .. )을 지원함.
				: url 을 사용한다는게 꼭 get 방식 처럼 직접 url 뒤에 보낼 데이터를 담는 방식을 의미하는게 아니다. 그냥 방식이 어찌됬건 url 을 활용하는걸 의미하는거다
					ex ) post 명령어 >> curl -X POST -F "file=@localfile.txt" https://example.com/upload
				: 어찌됬건 여기서는 파일 다운로드 받기 위해 설치한다

			: gnupg >> GNU Privacy Guard :  암호화 기술인 PGP를 기반으로 만들어진 암호화 소프트웨어.				
				: 디지털 서명을 사용하기 위해  설치

			: lsb-release >>Linux Standard Base release. 리눅스 배포판(우분투)의 버전을 확인할 수 있게 해준다. 


	2. 도커 공식 GPG 키 추가
		: GPG >> GNU Privacy Guard . 도커 이미지 인증을 확인할 때 사용한느 키.

식별자
