유닉스와 리눅스 >> 둘 다 OS
	: Unix >>  apple 과 같은 대기업에서 선호하는 유료 OS.
	: Linux >>  누구나 사용하기 쉬운 오픈소스 무료 OS. 
		: Unix 에서 파생된 운영체제이다.
		: 리눅스라는 용어는 리눅스 커널만을 뜻하지만, 리눅스 커널과 GNU 프로젝트의 라이브러리와 도구들이 포함된, 전체 운영체제를 나타내는 말로 흔히 쓰임


GNU 프로젝트. 운영체제 : 상업용이 아닌 누구나 사용할 수 있는 free software 를 만들자는 취지의 OS .
	: GNU 의 약자는 GNU is Not Unix. 즉,  unix 코드 를 포함하지 않는다는 말. ( unix 코드를 쓰지 않을 뿐 다른 방법으로 unix 의 "기능"을 구현해놨다. ) 즉, unix 와 별개로 완전 새롭게 만든 것. 
	: unix 를 대체하기 위한 용도. ( 얘도 운영체제이다 )


GNU 와 Linux : 
	: 일단 GNU 프로젝트가 먼저 시작함. GNU 프로젝트에서 커널이 좀 별로였는데, 좀 지나서 등장한 GNU 운영체제에 적합한 커널이 Linux . 이후 GNU OS는 Linux 를 커널로 채택함.
	: 사실 리눅스란 용어 자체는 리눅스 "커널"만을 의미하고, 리눅스 커널을 활용하는 윤영체제가 GNU 임. 우리가 리눅스라고 흔히 부르는건 GNU/LINUX 임.



데비안과 우분투 >> 리눅스 배포판
	: 우분투는 데비안을 기반으로 한 배포판.


리눅스 명령어 관련
	sudo >>SUperuser DO. 현재 사용자 권한이 어케됬건 root 권한으로 (sudo 뒤의) 명령어를 실행시킨다.

	| >> 파이프. 파이프의 앞 명령어에서 나온 결괏값을 파이프의 다음 명령어에 넣어준다. 
	- >> 이름이 한글자인 옵션
	-- >> 이름이 두글자 이상인 옵션
	$( 변수값 ) >> 명령어 치환 Command Substitution: 값을 명령어의 해당 부분에 동적으로 삽입해준다



	systemctl >> SYSTEMD + ConTroL. systemd 프로세스를 활용하여 프로그램을 제어하는 명령어.
		systemd >> 전반적인 시스템, 서비스를 관리하기 위한 프로세스.
			: systemd의 PID 는 1 이다. 그러니까 ㅈㄴ 중요한 프로세스란 의미. 

 
	usermod >> USER MODify. 사용자의 속성을 수정한다.
		: 사용자의 그룹, 홈디렉토리 등을 변경할 수 있다
		: 옵션
			-a : Append. 새로운 그룹을 추가할 때 사용
				; 이거 없이 다른 그룹에 걍 넣어버림 해당 사용자가 기존에 속했던 그룹에서 빠져버리게 되는거임 주의
			-G : Group. (뒤에 명시하는) 그룹에 사용자를 추가.




	apt >>Advanced Package Tool. 우분투에서 쓰이는 데비안 계열의 패키지를 관리하는데 쓰이는 도구
		: apt 에서의 "repository(저장소)" == 다운로드할 패키지가 있는 서버.
			: repository 자체가 다운로드할 패키지인게 아니다. 다운로드받을 패키지(들)가 있는 위치인거다. 
		: apt 패키지 설치하면, 기본적으로 있는 디렉터리인 /etc 아래 /apt 디렉터리가 생성됨
			: 응용프로그램 설치 삭제 업데이트 등의 작업을 하는데 사용된다
			: 주요 파일
			     : tip >> XXXX.d 형식은 파일이 아니라 디렉터리를 의미한다. 그리고 해당 디렉터리 는 .d 앞의  XXXX이름을 가지는 파일의 역할을 똑같이 수행하는데, 그걸 모듈화시켜서 할 수 있게 해준다
				(1) /etc/apt/sources.list :  리포지토리의 목록
					: deb [옵션1 옵션2 .. ] <리포지토리 URL> <배포명> <섹션> 의 형식으로 저장된다
						: [옵션] 부분에는 실제로 "[ ]" 를 써야된다.
							: 내부에는 다운로드 받을 해당 패키지(<리파지토리URL>로 다운받아지는패키지 )의 architecture 를 지정할 수 있고, 서명 검증하는데 쓰일 키를 지정할 수 있다. 
					: 주의 >> 여기에 추가한다고 해서 알아서 해당 패키지가 다운받아지는게 아니다. 패키지의 설치를 위해선 직접 "apt install 패키지명" 해줘야된다. 그럼에도 굳이 sources.list 에 정리해두는건 설치되는 패키지의 종속성관리 및 업데이트를 쉽게 하기 위해서, 보안을 위해서이다.
						: 다운받을 때 특정 gpg 키를 지정하여 검사한 후 다운받게 할 수 있다.
				(2) /etc/apt/sources.list.d/ :  추가적인 리포지토리 목록을 저장
					: 모듈화 하여 관리하기에 용이하다. /etc/apt/sources.list 파일에 죄다 나열하는 대신, /etc/apt/sources.list.d 안에 docker.list, google-chrome.list 와 같이 개별 파일로 나누어 저장할 수 있다
					: sources.list 와 동일한 수준.계층에 있다. (source.list 가 sources.list.d 내부에 있거나 그런게 아니란 말)
					
				(3) /etc/apt/apt.conf : APT의 전역 설정 파일

		: apt 명령어 vs apt-get 명령어
			:  내부동작의 큰 차이는 없고 둘 다 패키지를 install 할 때 쓰임
			: apt 명령어는 대체로 apt-get 기능을 다 커버하고, 성능도 더 좋은데, 가끔 apt-get 만 사용해야되는 경우도 있다. 이 경우만 apt-get 쓰면 되고 나머지는 다 apt 써라  

	dpkg >> Debian Package .  apt 와 마찬가지로 패키지 설치를 위해 사용되는데 의존성 문제가 있다. 이러한 문제를 해결한 것이 apt 이고 apt 를 더 많이 쓴다.



HTTP 특성
	1. connectionless >> response 끝나면 연결 바로 끊김
	2. stateless >> 이전에 통신했던 내용 저장 따로 안해둔다. 


무결성>> 데이터의 정확성, 일관성, 유효성이 유지되는 것


암호화 종류
    (1) 양방향. 복호화 가능. >> 원본 데이터를 복호화할 수 있어야 하는 상황, 예를 들어 안전한 정보 전송이 필요한 경우에 적합
	: https://velog.io/@480/RSA-%EC%95%94%ED%98%B8%ED%99%94-3%EB%B6%84-%EB%A7%8C%EC%97%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0

	1. 대칭키 암호화 : 하나의 키로 암호화, 복호화.
		: 대표적으론 AES , HMAC , HS256 
			: HS256 >>  HMAC + SHA256 . 
		: 보안측면에선 비대칭보다 딸린다 >> 어쨌뜬 키를 발급한 대상이 상대에게 한 번 이상 키를 넘겨줘야되니까. 

******2. 비대칭키 암호화: 각각 다른 키로 암호화, 복호화
		: 대표적으론 RSA
			: RSA라는 이름에 별 의미는 없다. 이 암호화 기법을 만든 수학자 3명의 이름을 따온것이다.

		: how it works >>  
			(1) 데이터를 받게 되는 쪽에서, 데이터를 주는 쪽에게 자물쇠와 해당 자물쇠를 잠글 키를 준다. 이때 키는 자물쇠를 잠글 수만 있고, 열 수는 없는 키이다.
			(2) 데이터를 주는 쪽에서 해당 자물쇠와 키로 보낼 데이터를 잠궈서 데이터를 전송한다
			(3) 데이터를 받는 쪽에서 자신이 가지고 있는 해당 자물쇠를 열 수 있는 키로 해당 자물쇠를 열어서 데이터를 확인한다. 	
				: 그러니까 복호화 가능한 키는, 데이터를 받는 쪽에서 항상 자신만 가지고 있던 것이다.
		: 공개되는 키를 public key, 비공개인 키를 private key 라고 한다.
			: public key , private key 개념에서 public 과 private 의 기준은 복호화 역할이냐 암호화 역할이냐 따라 정해지는게 아니라 공개냐 비공개냐에 따라 결정되는거다. 그리고 둘 중 한쪽은 무조건 암호화, 다른 쪽은 무조건 복호화 역할을 수행해야된다

    (2) 단방향. 해싱. 복호화 불가. >> 위조만 판단하면 되고,  민감한 정보를 포함해야하는 상황. ( ex- 회원가입시 db에 password 를 저장할 때 해싱하여 저장하여 개발자조차도 알 수 없게 한다 && 로그인 할 때 입력된 password 값을 db에 암호화되어 저장된 password 값과 비교하기 위해  입력된 password 값도 해싱하여 두 값이 같은지 판단한다. )
	: https://porolog.tistory.com/m/52
	: 대표적으론 SHA256
		: Secure Hash Algorithm 256 >>  입력된 데이터를 256비트 길이의 해시값으로 변환
			:  데이터의 무결성을 확인하는데 적합하며, 원본 데이터를 추론할 수 없는 고유한 해시값을 제공(산출되는 해시값은 원래 데이터에 대한 정보를 전혀 가지지 않는다)



spring security 에서의 암호화 >> 단방향 양방향 모두 사용된다.
	: 회원 가입을 할 때는 비밀번호를 저장하기 위해 SHA256 과 같은 단방향 암호화 알고리즘을 사용하여 데이터베이스에 비밀번호를 암호화된 형태로 저장시키고 
		: 개발자조차도 회원의 비밀번호 알 수 없다
		: 무결성 확인만 할 수 있고 값은 알 수 없기에 비밀번호를 까먹었을 때 원래 비밀번호를 알려주는게 아니라 아예 비번을 새로 파게 하는거다

	: 로그인 할 때는 클라이언트가 입력한 비밀번호를 SHA256으로 암호화하여 그 값을  데이터베이스에 저장한 암호화된 비밀번호와 비교하여 인증을 하고

	: 로그인 성공 시(비밀번호가 동일한 게 확인된 이후에는) jwt 토큰을 서버가 클라이언트에게 발급해주는데, 이때 signature 부분은 header 와 payload 를 base64 인코딩 한 값을  secret key로 HS256 과 같은 양방향 암호화 알고리즘을 사용하여 생성된다
		: 주의해야할 점은 jwt 토큰의 payload 자체는 아주 해독하기 쉬운 base64 인코딩되기 떄문에 비밀번호와 같은 민감한 정보를 담아서 보내면 안된다. 주로 username 정도만 payload 에 담아서 보낸다

	: 이후 인증된 클라이언트의 요청인지 확인하기 위해 클라이언트의 헤더 부분에 있는 jwt 토큰을 서버에 저장된 secret key 로 복호화하여 판단한다
		: 헷갈리지 말아야할 것은 HS256 은 "양방향" 이기 때문에 따로 복호화 전용 키가 있진 않고, 앞서 암호화 하는데 사용하였던 secret key 로 또 복호화 하는 것이다.




(디지털) 서명 >>데이터의 무결성을 증명하는 인증수단. (이 데이터는 해커로부터 온 것이 아니라 정상적으로 보내진 데이터다)


서명되었다 >> 해당데이터에 인증수단을 내장하게했다.


SSL Secure Sockets Layer 보안 소켓 계층, TLS  Transport Layer Security >> 암포화 기반 인터넷 보안 프로토콜.
	: 특징
		1. 핸드셰이크라는 인증 프로세스를 도입해 두 장치(클라이언트, 서버)의 ID 를 확인 
		2. 데이터에 디지털 서명하여 데이터 무결성 제공
		3. RSA 와 AES 섞어쓴다.
	: SSL 이 업데이트 한게 TLS  이다. SSL은 현재 사용 중인 TLS 암호화의 전신
	: SSL/TLS를 사용하는 웹사이트는 "HTTP" 대신 "HTTPS" 쓴다.



SSL 인증서 >> 서버의 신원을 증명하는 신분증
	: SSL/TLS 인증서 가 있는 웹사이트에서만 SSL 프로토콜의 사용이 가능하다.
	: 그러니까 클라이언트가 올바른 서버와 통신하고 있는지 확인하는 용도의 파일. 중간에 요청 뺐어서 제3의 서버로 요청을 보내게 하는 DNS 스푸핑 같은걸 막는다.
	: public key 와 private key (비공개) 를 포함한다.
	: https://aws-hyoh.tistory.com/59



CA >>  SSL 보안 인증서를 발급 및 인증하는 기관"들"
	: https://babbab2.tistory.com/5
	: 개인적으로도 SSL 인증서를 발급할 수 있지만, 그 인증서를 인증해 줄 기관이 있어야 신뢰 가능하기에 어떤 기관을 중간에 껴야 실질적인 SSL 인증서의 기능을 하는 인증서의 발급이 가능
	: certificate authority 의 약자	
	: ( 인증서 발급 주문 넣는 회사와는 별개로) CA 는 자체적으로 public key 와 private key 를 가진다.
		: private key 누설되면 그 CA 기관은 ㅈ되는거다


	: certifacate chain . chain of trust . >> 
		: 인증기관이 띡 하나만 존재하면, 해당 인증기관의 private key 만 털면 되니까 위험하다. 그래선지 2~3계층 구조로 이뤄져있다. 
		: SSL 인증서는 n개의 intermediate CA 에서 n 번 검증을 받은 뒤, 최종적으로 Root CA 에게 검증을 받고, Root CA 는 스스로를 검증하는 방식으로 검증된다.


		1. Root CA : 모두가 신뢰하기로 합의한 최상위 인증기관
			: 자체 서명 인증서를 보유한다 << 그러니까 얘 자기자신은 스스로 인증해준다는것. 위에 누가 더 없으니까
			: 루트 CA의 인증서"들"은 브라우저나 운영 체제에 미리 설치되어 있다. 그리고 이 목록은 주기적으로 업데이트 된다. 만약 해당 CA 리스트에 없는 
			: intermediate CA 처럼 root CA 기관도 여러개 존재하고, 인증 과정에 여러개 사용 가능하다

		2. Intermediate CA: 중간 기관(들) 
			: root ca 로부터 인증서를 발급받는다
			: 사용자에게 인증서를 발급해줄 수 있다
			: 여러개의 중간 기관이 존재할 수 있다.

		3. End-entity Certificate : 최종 엔티티 인증서
			: 개발자가 구입하게 되는 SSL 인증서. 
			


	: SSL 인증서 발급 절차
		1. 회사가 CA에게 인증서 발급에 필요한 정보( domain 등과 같은 사이트 정보와  public key )와 함ㄲㅔ 인증서 발급 요청
		2. CA 가 해당 사이트가 안전하다 판단하면 OK 함. 그리고 인증서 제작함
			step1. "회사"가 제출했던 public key 를 SHA-256 등으로 해시하여 인증서에 "finger print "로 등록
			step2. 앞서 등록한 "finger print" 를 "CA"의 private key 로 암호화하여 인증서에 "signature" 로 등록

		3. 회사에게 발급한 인증서 줌


	: 발급받은 SSL 인증서를 이용한 인증 및 통신 절차
		: 운영체제나 브라우저들은 미리 CA 리스트를 포함하고 있다.
			: CA 리스트 >> 공인 인증된 Root CA 기관들에 대한 리스트로, 그들의 "public key" 정보도 포함한다. 
			: 때문에 매번 직접 찾아가진 않아도 된다
			: CA 리스트는 주기적 업뎃 된다

		1. 클라이언트가 해당 서버에 접속하려고 시도
		2. 서버가 CA 에서 발급받은 인증서를 클라이언트에게 전달
		3. 클라이언트는 받은 인증서를 검증
			step1. 해당 인증서가 클라이언트 자신이 가진 CA 리스트에 있는 기관에서 발급받은 것인지 확인
			step2. 클라이언트는 CA 리스트에 저장되있는 해당 CA 기관의 public key 로 서명부분을 복호화 한다.
				: public key , private key 개념에서 public 과 private 의 기준은 복호화 역할이냐 암호화 역할이냐 따라 정해지는게 아니라 공개냐 비공개냐에 따라 결정되는거다. 그리고 둘 중 한쪽은 무조건 암호화, 다른 쪽은 무조건 복호화 역할을 수행해야된다

			step3. 클라이언트는 복호화한 signature 부분의 내용과 인증서에 기재된 public key 부분이 일치하는지 확인한다. 일치하면 검증된거다.
				: 앞서 인증서 발급할 때 signature 부분에 해당 회사의 public key 를 해싱한 거라서 그런거다


		4. 인증서를 검증에 성공시 클라이언트는 해당 서버를 신뢰할 수 있는 서버로 간주한다
		5. 클라이언트는 서버와 TSL 암호화 통신을 시작하기 위해 "handshake" 를 한다. 



TSL 의 handshake >> 실제 데이터를 주고 받기 전, 서버와 클라이언트가 서로 악수를 하며 연결할 수 있는지 상태를 살피는 것. TSL 암호화 통신에 사용할 대칭키를 클라이언트 측에서 서버 측으로 넘겨주는 과정
	: https://babbab2.tistory.com/7>> 추후 계속.




plugin >> 확장프로그램. 추가기능. 
	: 해당 프로그램에 특정 기능을 추가하기 위해 추가하게되는 확장 도구 같은거.. 
	: 웹 브라우저 뿐 아니라 IDE 등에서도 다양하게 활용된다.

---------------------------------------------------------------------------------------------------------------

--도커 설치하기--


사전 셋팅 >> 도커 리포지토리 와 통신할 수 있는 환경 설정
	 :  도커 리포지토리 >> 도커패키지가 저장된 서버.
	1.  apt 패키지 인덱스를 업데이트 >>sudo apt-get update
	2,  apt가 HTTPS에서 리파지토리를 사용할 수 있게 하는데 필요한 패키지를 설치 >>sudo apt-get install ca-certificates curl gnupg lsb-release
		: install 뒤에 쭉 나열된건 다운로드 받을 패키지 목록을 띄어쓰기로 구분해둔것.ㄴ
		: ca-certificates >> CA 목록 패키지

		: curl >>  Client URL. 클라이언트에서 url 을 사용해서 서버와 데이터를 송수신 하는걸 가능하게하는 명령어 툴.
			: 다양한 프로토콜(HTTP , HTTPS , TELNET , .. )을 지원함.
			: url 을 사용한다는게 꼭 get 방식 처럼 직접 url 뒤에 보낼 데이터를 담는 방식을 의미하는게 아니다. 그냥 방식이 어찌됬건 url 을 활용하는걸 의미하는거다
				ex ) post 명령어 >> curl -X POST -F "file=@localfile.txt" https://example.com/upload
			: 어찌됬건 여기서는 파일 다운로드 받기 위해 설치한다

		: gnupg >> GNU Privacy Guard :  데이터를 암호화/복호화하고 디지털 서명을 생성 및 검증하기 위한 도구
			: PGP Pretty Good Privacy 를 기반으로 만들어졌다.
			: ex ) 오픈소스 소프트웨어 개발자는 public GPG 키로 소프트웨어 패키지에 서명하고(= public key 를 패키지에 첨부하고 암호화), 사용자는 private GPG 키를 사용하여 다운로드한 소프트웨어가 (변질되지 않은) 원본임을 알 수 있다(= private GPG 키로 복호화 하여 public key 가 똑같이 나오는지 확인).
			: 이 패키지는 설치 이후 "gpg"라는 명령어를 통해 사용 가능하다 
			: 옵션
			    (1) 암호화 및 복호화
				--encrypt 
				--decrypt 

			    (2) 디지털 서명 및 검증 
				--sign 
				--verify  

			    (3) 공개/비밀 키를 생성 및 관리
				--gen-key : 새 키 생성
				--list-keys : public key 확인 
				--list-secret-keys : secret key 확인 
				--import 파일경로 : 해당파일에서 키를 가져옴
					: 보통 이러한 파일은 .asc 확장자

			    (4) ASCII 형식의 GPG키 <--> 바이너리 형식의 GPG키 변환
				: dermored 와 amored 	>> pgp 와 gpg 상에서 데이터를 각각 binary,ascii 형식으로 인코딩하는 걸 의미.	 
				--dearmor :  ASCII 형식 --> 바이너리 형식으로 변환
				--armor :  바이너리 형식 --> ASCII 바이너리 형식으로 변환



			: https://jykim74.tistory.com/129
			: https://uyfuyfuy-042.tistory.com/entry/GPG-keyPGP



		: lsb-release >>Linux Standard Base release. 리눅스 배포판(우분투)의 버전을 확인할 수 있게 해준다. 


	3. 도커 공식 GPG 키 추가 >> curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
		: -fsSL >> curl 명령어의 옵션 여러개 쓴거다.
			: f , s , S >> 출력 관련 옵션
			: L >> 리디렉션을 따라가게 하는 옵션

		: "https://download.docker.com/linux/ubuntu/gpg"  >> 도커 GPG 키를 다운로드 받을 수 있는 URL. 
			: public key 가 다운로드 된다

		: | >> 파이프. 앞 명령어 결과를 뒷 명령어의 입력으로 넣어준다.
		: gpg >> gnupg 패키지 사용하기 위한 명령어
		: 굳이 --dearmor  를 써서 키를 바이너리 형식으로 저장하는 이유 
			1. 일부 패키지(ex - apt )는 바이너리 형식의 데이터 처리만 가능하기 때문. 
			2. 컴퓨터가 더 효율적으로 처리할 수 있으니까
				: ASCII 는 사람이 읽기 쉽도록 인코딩해둔것


	4. docker.list( 도커 리파지토리)를 APT의 sources.list.d 에 추가 >> echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
		: 이 과정을 통해 도커 패키지 설치 및 업뎃 할 때 APT 가 해당 저장소를 참조할 수 있게 됨
		: echo >> 해당 명령어 뒤의 문자열을 (명령어로써) 실행. 출력
			: 가독성 향상의 목적이라고 한다.
		: deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable >>그러니까 apt가 https://download.docker.com/linux/ubuntu 경로의 패키지를 다운받을건데, 현재 시스템의 아키텍처(예: amd64)에 맞는 패키지를 택해 다운로드하게 하고, 그 패키지에 대한 검증을 할 때 앞서 저장해둔 public key 인 /etc/apt/keyrings/docker.gpg 로 진행하게 한다.
		: tee >>  명령어의 출력 결과를 파일과 화면에 동시에 출력하게 한다
			: T 자 모양으로 출력한다해서 붙여진 이름.

		: /dev/null >>  특수한 파일
			: 여기로 출력하면 해당 데이터는 걍 버려진다. 출력 결과를 버리고 싶은 경우 유용하다
				ex ) echo "Hello, World!" > /dev/null : 화면엔 암것도 출력안됨

			: 여기로 읽기하면 EOF 를 반환한다. 
				ex ) command < /dev/null : 빈 입력 제공





도커 설치
	1. apt 패키지 업데이트  >> sudo apt-get update
		: 본격적 도커 설치 전 설치된 패키지들을 최신상태로 업데이트 한다.
		: 이 과정에서 error 나면서 ... does not have a release file 이따구로 나오는건 앞서 기초 세팅 과정의 3, 4 명령어를 이상하게 입력해서 난 에러이다. 앞서 설치한 파일들 모두 삭제( 각각 /etc/apt 의 하위 디렉터리에서 찾아서 rm )하고 3, 4 으로 다시 다운로드 해라.

	2. 도커와 관련한 여러 패키지 설치 >> sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
		: install 이라는 서브 명령어 뒤에 나열된 건 설치할 패키지들.
			docker-ce >> Docker Community Edition 패키지
			docker-ce-cli >> Docker Commutnity Edition 의 CLI 도구.
			containerd.io >> 컨테이너 런타임 도구. 
				: 컨테이너의 수명 주기를 관리. 컨테이너 이미지를 풀링, 저장소 관리, 네트워킹을 처리
			docker-buildx-plugin >> 빌드관련 플러그인(확장프로그램) 
				; 멀티 플랫폼 이미지를 빌드하는 데 유용.
				: 도커 이미지를 빌드하는 새로운 기능과 명령어를 제공
			docker-compose-plugin >> Docker compose 라는 플러그인.
				: Docker Compose >> YAML YAML Ain't Markup Language 를 사용하여 멀티 컨테이너 도커 애플리케이션을 정의 및 실행할 수 있게 함. ( 그러니까 컨테이너 여러개일 때 관리하기 쉽게 해주는 얘라는 거임)

	3. 제대로 설치되었는지 확인 >> systemctl status docker
		: 초록글씨 나오면서 active 써있으면 성공한 것.


	4. 도커 명령어를 관리자(root) 뿐 아니라 사용자도 사용할 수 있게 하기 : 귀찮으니까 >> sudo usermod -aG docker $USER
		: 리눅스에서 "$USER" 변수는 현재 사용자의 이름을 나타낸다 
			: 예제의 경우 eevee 이다.
		: 사용자를 docker 그룹에 추가한다.

	5. 재로그인 >> logout 후 다시 로그인
		: 수정된 내용을 반영하기 위해선 재로그인 필요

	6. 최종 테스트 >> docker run hello-world
		: python 이나 java 의 hello world 급의 명령어이다.



