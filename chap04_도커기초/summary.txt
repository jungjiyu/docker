도커 기초 지식
	- 도커의 구성 요소, 작동방식
	- 컨테이터로 실행하는데 필요한 내용 학습
	- 관련 명령어
	- 도커 네트워크, 스토리지

------------------------------------------------------------------------------------------

기본명령어
	vim 으로 텍스트파일 생성 >> vim 새파일명.txt
	텍스트 파일의 내용을 간단히 출력원하면 cat 을 사용 >> cat 파일명.txt
	현재 디렉터리 출력 >> pwd 


apt install 할 때, 항상 apt update 를 먼저해라. 
	: 그래야 기존 설치한 패키지들이 최신 상태로 유지되서, install 할 때 의존성 패키지도 최신 버전으로 설치되서 좀 관리하기 편하다.

alt + F2 ,F3 ...  누르면 새로운 터미널 열 수 있다 !!
	: 인터넷의 다른건 해봤을 때 안먹혔다
	: 특정 터미널로 이동하고 싶을 땐 "alt + 해당Fn" 누름 된다 


architecture 
	: cpu 의 종류를 의미.
	: 대표적인 architecture
		: intel 기반 >> 현존하는 "pc 프로그램" 대부분이 이 아키텍처를 지원
			1.  x86 >> 32 bit 기반 cpu 
			2.  amd64(= x86_64) >> 64 bit 기반 cou
				: 사실 완전 intel 기반은 아니고, 하위 호환 개념. 쩄뜬 잘 작동한다. 

		: arm 기반 >> "모바일 앱"이 이 아키텍처를 지원
		    : pc 프로그램의 경우 linux 와 mac 은 arm 을 지원하지만, windows 는 지원을 안함
			1. arm >> 32 bit 기반 cpu
			2. arm64 >> 64 bit 기반 cpu

	: 애플리케이션, 라이브러리가 실행될 서버의 아키텍처를 알아야하는 이유 >> 애플리케이션은 결국 "사전 컴파일"된 바이너리( 라이브러리도 대부분 사전 컴파일되어 제공된다 ). 이때 이 컴파일을 어떤 CPU 로 했느냐 따라 결과물이 달라진다.  intel 기반 cpu 로 빌드한 애플리케이션을 그냥 arm 기반 cpu 로 가져오면 실행이 안된다. 
	: 도커 이미지 같은 경우도,  pull 받을 때 그 머신의 CPU에 따라 맞는 아키텍처를 받아야된다.
		: docker hub 가보면 x86-64 , arm64 등 따로 구분되어있다  
	: https://velog.io/@480/%EC%9D%B4%EC%A0%9C%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%8F%84-CPU-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%A5%BC-%EA%B5%AC%EB%B6%84%ED%95%B4%EC%95%BC-%ED%95%A9%EB%8B%88%EB%8B%A4





하위 명령어
	: 리눅스에서 기본 명령어 다음에 하위 명령어가 올 수 있다. 
	: 각 하위 명령어는 일반 명령어와 마찬가지로 옵션 과 인수를 가질 수 있다.
		: ex ) docker run hello-world , docker pull ubuntu
	: 하위 명령어와 인수를 구별하는 tip
		: 하위 명령어는 보통 특정 작업을 지칭하는 동사형이다.
			: 사실 걍 보면 아 이새끼는 인수가 아니구나 라는 느낌이 온다
		: 인수는 보통 특정 자료 같은 명사형이다 .




digest : 해시함수 산출값.
	: DIGEST vs ID >> 모두 식별자 개념
		: digest 는 찐으로 고유한 느낌 >> docker 에서 digest 는 push 될 때 결정되고, pull 이 어디서 되건간에 항상 그 값을 유지한다.
		: id 는 환경적.지역적으로 고유한 느낌 >> docker 에서 id 는 pull 되는 환경에서 , 도커가 내부적으로 사용하는 식별자. (캐시등에서 활용하기 위해)


매니페스트 manifest : 어떤 것에 대한 명단. 목록.
	: 영단어 뜻 자체로는 "화물 목록" 이다.
	: https://bsnippet.tistory.com/7


tarball :  ".tar" || "".tar.gz" 파일을 일컫는 전문 용어
	: ".tar" 확장자여서 tar + ball 이라고 하는 듯?
	: .gz 는 해당 파일을 압축시킨 파일이다


Dockerfile : 뭐 이후 챕터에 나오는 것 같은데 이건 그때 정리
	: https://seosh817.tistory.com/381


(일반적인) 이미지 : 물리적인 광매체(cd, dvd 등)를 압축한 파일. 
	: 광매체에 이미지라는 표현을 많이 쓰다보니 이미지 파일이라는 이름이 붙여진것
	: 다운로드/저장/백업 용으로 쓰인다.
	: 굳이 광매체를 압축해서 이미지로 만든 건 일일이 CD 같은거 들고다니기 귀찮으니까.
	: https://blog.naver.com/taeho930/220488967313 



도커 이미지 image : 컨테이너 형태로 소프트웨어를 배포하기 위해, 필요한 모든 파일을 포함하는 패키지.
	: 모든 도커 컨테이너는 도커 이미지를 기반으로 생성된다.
	: debain OS 에서 apt install 을 하면 기본적으로 apt 레파지토리에서 패키지를 내려받듯이 도커는 기본적으로 docker hub 에서 이미지를 내려받는다.

	: 구조 >> 효율적 사용을 위해 레이어 구조로 이뤄짐.
		: 도커 이미지는 컨테이너를 실행하기 위한 모든 파일을 가지고 있기에 용량이 크다.( 수백 MB )
			: (이미지를 수정없이 계속 사용한다면 별 문제 없겠지만) 이미지에서 파일 하나를 수정한다고 했을 때, 기존이미지를 또 다운 받아서 처음부터 세팅 다 다시하고 새로운 내용을 받아야된다면 매우 비효율적일 것. >> 이러한 문제 해결을 위해 도커 이미지는 레이어 구조로 이뤄짐

		: 여러개의 read only (읽기 전용. 수정 불가)레이어 로 구성되고, 파일이 추가되거나 수정되면 새로운 레이어가 생성됨 >> base layer(기존 layer들)은 변경 필요 없이 새로운 layer 를 추가만 하면됨
			: read only 이기 때문에 파일을 추가할 때 뿐아니라, 수정할 때에도 새로운 layer 가 추가된다
			: 이미지는 read only 이기에 특정 시점의 도커 컨테이너의 상태를 담은 "스냅샷"이라고 볼 수 있다.
				 : 특정 시점의 상태를 사진 찍어둔 것처럼 그대로 저장해둔 것이니까. 
			: 이미지 자체는 읽기 전용이기에 실행이 불가하다.
			: 동일한 환경을 가진 컨테이너를 마음껏 생성 가능하게 해준다


		: 이미지를 pull 시키면 해당 이미지의 레이어 단위로 차곡차곡 pull 된다.

	

	: 용어
	    : REPOSITORY >> 특정 도커 이미지 자체
		: ex) python , ubuntu
  	    : TAG , INDEX >> 특정 도커 이미지의 특정 버전
		: ex) python:3.9.19 에서 "3.9.19"
	    : MANIFEST >> 도커 이미지의 특정 아키텍쳐. 
		: ex) python:3.9.19 의 amd64 버전
		:"config" + "layer들". 다양한 환경에서 해당 이미지를 활용할 수 있도록. "특정 config" 와 "레이어들"을 제공. 
			: config >> 해당 이미지가 어떻게 만들어졌고, 어떻게 실행 가능한지 등에 대한 메타데이터가 들어있다
			: 이미지 "매니페스트" 라고 부르는건, 여러 레이어들을 포함하는 개념이라. 레이어들의 목록이라 그런 것 같다.


	    : DIGEST
		: INDEX DIGEST >>  "태그"에 대한 식별자
			: SHA256 해시 값을 사용하여 생성된 값으로, 해당 이미지가 도커레지스트리에 push 될 때 결정된다. (매번 pull 받을 때마다 새롭게 구해지는게 아니다)
			: when 사용
				: 이미지가 변경되지 않았음을 보장하는 데 사용
				: 각 이미지를 식별하기 위해 사용
			: docker hub 에서 확인 가능하다 <-- index digest 옆에 표기되어있다
			: docker image pull 할 때도 확인 가능하다 <-- 끝쪽 부분에 "Digest : ... " 으로 출력된다.			

 		: MANIFEST DIGEST >> "아키텍쳐"에 대한 식별자
			: 특정 태그의 도커 이미지의 특정 아키텍쳐를 의미
				: 그러니까 마냥 amd64과 같은 아키텍쳐에 대한 식별는 아니고, "python:3.9.11" 과 같은 특정 태그의 도커 이미지 중 아키텍쳐가 amd64 인것을 의미한다.
 
 		: LAYER DIGEST >> "레이어"에 대한 식별자
			: 특정 아키텍쳐의 특정 태그의 도커 이미지의 특정 레이어를 의미
			: docker image pull 할 때도 확인 가능하다 <-- 앞부분에 "  ... : Pull complete" 으로 출력된다.			
	
	    : ID
		: IMAGE ID >> 다운로드한 도커 이미지에, 로컬에서 부여한 ID값.
			; 로컬에서 이미지 대한 작업 (삭제 등) 할 때 사용된다.
			

	: 기존 이미지를 수정하여 새로운 이미지로 저장하기
	    : https://gracelove91.tistory.com/111
	    : 주의 >> 이미지를 수정/생성하는 과정이지만, 이미지자첸 read-only 라 이미지적으로 작업하는 내용이 없어, 이 과정서 하위 명령어는 "image" 가 아닌 "container" 이다. 
		: 원본이미지를 실행시켜만든 컨테이너로 다양한 수정작업을 수행하더라도, 바뀌는건 해당 컨테이너지, 이미지가 아니다. 해당 원본이미지를 기반으로 또 docker container run 수행시키면, 수정이 반영되지 않은 형태로 실행된다. 변경을 가한 컨테이너id를 기반으로 docker container start 를 해야지만, 변경된 내용이 적용된 형태로 실행시킬 수 있다. 이를 아예 base 이미지로 저장하여, 이를 디폴트로 컨테이너를 만들 수 있게 하고 싶을 때 commit 이란 작업을 수행하는 것이다.

		1. 일단 원본 이미지를 기반으로 생성된 컨테이너에 내부 접속한다	
			: 그냥 실행시키면 어케 반영할껀데? 들어가야지 뭘 할꺼아냐 
		2. 해당 컨테이너를 수정한다. (새로운 패키지 다운받던지 뭘 없애던지...)
		3. 해당 컨테이너를 커밋한다.  이떄 새로 생성될 이미지의 이름을 정해준다.
			: docker container commit [컨테이너Id || 컨테이너name] [ 새이미지명 ] 
				: 그러니까 현재 컨테이너를 기반으로, 새로운 이미지를 생성하는거다.


	: 도커 레지스트리에 저장되어 관리된다.
	: 일종의 템플릿이라고 볼 수 있다.
	: 독립적이라 의존성 고려 필요 없음
	: https://seosh817.tistory.com/377



(통상적인) 데몬 Daemon >> 백그라운드 프로세스. 밑에서 돌아가는.
도커 데몬 >> 도커 관련 작업을 하는 백그라운드 프로세스




도커 컨테이너 container : 도커 이미지를 실행할 수 있는 인스턴스 instance .
	: 도커 이미지로부터 생성된다. 
	: 도커 개념에서 등장하는 "instance" 란 용어는 주로 특정 이미지로 생성된, 도커 컨테이너를 지칭한다.
	: 특정이미지를 기반으로 컨테이너를 생성하는 과정
		step1. 컨테이너가 실행될 떄, 도커이미지가 이미지 레이어 형태로  복사된다. 이 이미지 레이어들은 도커 이미지에서와 마찬가지로 read-only 이다 >> 이미지 베이스(복사된 이미지 레이어들)은 수정 불가이다.
		step2. 복사된 이미지 레이어들의 위로 read-write 인 "컨테이너 레이어"가 생성된다 >> 컨테이너는 수정 가능하다
			: 이 컨테이너 레이어는 해당 컨테이너가 삭제될 떄 함께 삭제된다.

	: 용어
	    : CONTAINER ID 
		: 하나의 이미지로 다수의 컨테이너를 생성할 수 있으므로, 이의 식별을 위해 로컬에서 각 컨테이너가 ID를 가질 필요가 있다.

	    : CONTAINER NAME
		: 컨테이너 생성당시 --name 옵션으로 이름을 설정하지 않은경우, 도커 엔진이 임의로 형용사와 명사를 조합해 만든다. 이또한 "고유하다"


	: 도커 컨테이너의 상태 
		CREATED : 막 생성된 상태	
		RUNNING : 실행중인상태
		    : attatched / detached mode	
			: attached mode. >> 해당 컨테이너의 터미널 세션에 연결된 상태. 즉 해당 컨테이너에 내부 접속하여, 사용자의 기존 입력(?)이 차단되고 , 실행중인 컨테이너의 출력(로그)이 나오는 상태.
				: 터미널과 프로세스가 부모-자식으로 연결되므로, 터미널이 끊어지면 컨테이너까지 종료된다. 좀 위험하기 때문에 테스트 할 때만 이용해야된다.
				: 컨테이너의 실행 내용이 면전에 나오는거라 foreground mode 라고도 한다.
				: docker run VS docker attach 
					: docker run 실행시 기본 attached mode이다 (옵션으로 -d 옵션을 주면 detached mode로 실행시킬 수 있다)
					: 둘 다 attach mode 인건 맞는데, 그래도 약간 다르다.
						: docker run 은 현재 터미널 세션을 새로 생성한 컨테이너에게 할당 한 후, 그걸 사용한다는 개념이다. 그러니까 터미널 세션 할당과 연결을 둘 다 하는거다.
						: docker attach 는 어딘가에서 돌아가고 있던 터미널 세션을 현재 터미널 세션에 연결하여 사용하겠단 말이다. 그러니까 터미널 세션 연결만 하는거다.
				: 컨테이너를 start 시킨 상태에서 해당 컨테이너 내부에 접속하고 싶은 경우 attach 명령어를 사용하여 내부 접속 할 수 있고, 나오고 싶으면 exit 하면 된다.
		

			: detached mode>>  해당 컨테이너의 터미널 세션에 연결되있지 않은 상태. 즉, 사용자의 터미널 입력이 차단되지 않고, 실행중인 컨테이너의 로그가 따로 나오진 않는 상태
				: 터미널에 관계없이 지속적으로 실행 가능하다 .서비스형태로 실행할 때 attached mode 보단 많이 사용한다.
				: attached mode 와는 다르게 딱히 터미널 세션 연결, 할당 그런 개념이 사용되지 않는다.
				: 기본적으로 detached mode 에선 컨테이너의 로그가 나오지 않는데. 별도의 명령어로 지금까지 출력된 로그를 확인 하거나 , 앞으로의 로그를 계속 출력되게 할 수 있다
					: docker log [컨테이너id] >> 과거 로그내역 출력
						: 옵션으로 -f 를 주면 앞으로 로그내역 출력하게 할 수 있다.
				: 컨테이너의 실행 내용이 대놓곤 안나오는거라 background mode 라고도 한다.
				: docker start 실행시 기본 detached 상태이다

			: https://velog.io/@arnold_99/Docker-Attach-and-Detach
			: https://velog.io/@dong5854/%EB%8F%84%EC%BB%A4%EC%9D%98-attach-mode%EC%99%80-detach-mode

		RESTARTING : 재시작 "중"인 상태
		PAUSED : 중지 상태  
		EXITED : 종료 상태
			: EXITED( 0 ) >> 정상 종료됨
		DEAD : 컨테이너가 더이상 실행불가한 상태. 제거만 가능한 상태.
		: https://ttasjwi.tistory.com/100




	: 도커 컨테이너를 실행하는 과정
		: 컨테이너를 실행시키고, 컨테이너 내부의 프로세스가 모두 종료되면 .해당 컨테이너 역시 종료된다.

	: 특 
		1. 자체적으로 파일 시스템을 가진다
		    : 그러니까 host 나 다른 컨테이너에 설치되있는 패키지라 해서, 해당 컨테이너에서 쓸 수 있는게 아니란 말이다.
			ex )  터미널로 다른 컨테이너에 접속했을 때 , VM 에 net-tools 를 install 한 상태라고 해도, 해당 컨테이너 자체에 net-tools 를 install 한 적이 없다면 ifconfig 해도 COMMAND NOT FOUND 만 나온다.
			    : 그럼에도 불구하고 어떻게 가벼울 수가 있는 걸까? : 컨테이너는 VM 과는 다르게 자체적으로 운영체제를 가지진 않고, host os 를 활용하기 때문.


		2. 각 컨테이너는 독립적으로 실행된다


	: 도커 컨테이너에게 실행/중지/재실행/삭제 등의 명령을 내릴 수 있다
		
	  


도커의 구성요소 
    : 도커 클라이언트 <--> 도커 호스트 <--> 도커 레지스트리
	(1) 도커 클라이언트 Docker Client : 도커에 명령을 내릴 수 있는 CLI 도구.
		: 생각해보면 네이밍이 그럴싸한게, 요청하는 쪽이니까. 

	(2) 도커 호스트 Docker host : 도커가 설치된 (물리적인/가상의)서버.
		: 역시 역시 네이밍이 그럴싸한게, 요청에 따라 무언가 작업을 진행시키고 response 하는 쪽이니까.
		: 도커 데몬 Docker Daemon >> 도커와 관련된 리소스를 관리하는 백그라운드 프로세스

	(3) 도커 레지스트리 Docker Registry : 도커 이미지를 사용자들끼리 공유할 수 있는 플랫폼.
		: 레지스트리 종류 
			1. 공개 public : 벤더에서 구축한 레지스트리  
				: Docker 의 공식 레지스트리인 Docker hub 가 가장 유명하다
					: Docker Hub >> 다운 원하는 이미지를 검색 후 클릭하면, 해당 이미지에 대한 상세 정보와 다운로드 받을 수 있는 명령어를 확인 가능 

			2. 개인 private : 개인이 (팀원과의 공유등을 목적으로) 직접 구축한 레지스트리.





pull
    : 일반적인 pull >> 원격의 데이터를 로컬에 반영한다.
    : 깃허브에서의 pull
	(1) pull request >> 일반적이지 않은 pull. 특정 변경사항을 해당 원격 저장소에 반영해달라고(merge) 요청하는 것. 
		: 좀 헷갈리게 작명되었는데, 변경 내용을 끌고 온다는 맥락에서 pull 이란 용어를 쓴다고 한다.
	(2) git pull >> 일반적인 pull . 원격 저장소의 내용을 로컬 저장소에 반영하는 것.

***: docker 에서의 pull >>일반적인 pull. 원격의 데이터를 로컬에 다운 받는다.




애뮬레이션 Emulation : 특정 대상을 흉내내는데, 하드웨적인 동작까지 따라하는것
	: simulation VS Emulation >> 둘 다 무언가를 흉내내는 것.
		simulation : 소프트웨어 수준까지만 따라함
		emulation : 하드웨어 수준까지 따라함



가상터미널 TTY TeleTYpe : 사용자의 입력을 받아들이고, 출력을 화면에 표시하는 인터페이스 
	: tele + type . 원격에서 타이핑한다.
	: 한국어로 "가상" 인 이유는, 이전엔 터미널이 원래 물리적인 기기였는데 지금은 소프트웨어적으로 구현된 터미널을 사용하기 때문.
		: 가상머신의 터미널 뿐 아니라 그냥 내 컴터의 터미널도 "가상" 터미널인 것.

	: ＠에게 TTY 를 할당한다 == 현재 가상터미널에서 ＠와 상호작용가능하게 하겠다. 즉, 입력을 전달하고 출력을 보여주겠다.



터미널 세션 : 사용자가 특정 대상과 상호작용할 수 있는 텍스트 기반의 인터페이스. 명령어를 입력하고, 그 결과를 텍스트 형태로 출력받는 환경
   : 터미널 세션을 할당  VS 터미널 세션에 연결 >> 일단 둘다 접속한다는 개념이다.
	: 특정대상에게 터미널 세션을 할당 == "새로운" 터미널 세션을 시작하여 특정 대상(사용자, 프로세스, 컨테이너 등)이 해당 터미널 세션을 사용할 수 있게 하는 것을 의미

	: 특정대상의 터미널 세션에 연결 == "이미 실행 중인" 터미널 세션에 다시 연결하여 해당 세션에서 진행 중인 작업에 접근하고 상호작용하는 것을 의미 
		: docker run -it >>  터미널 세션 할당 && 터미널 세션 연결 : 새로운 생성된 컨테이너가 현재 터미널 환경을 사용할 수 있게 하고, 그 터미널 환경을 사용하겠다. 
		: docker attach >> 터미널 세션 연결 : 해당 컨테이너에 대해 이미 존재하던 터미널에 접속해   작업하겠다. 




셸 shell : 운영 체제와 상호작용 할 수 있게하는(=사용자의 명령어를 운영체제가 알아먹게 통역 및 실행) 프로그램. 
	: CLI , GUI 의 형태로 제공됨.
	: 쉘 스크립트 >> 쉘에서 사용할 수  있는 명령어로 쓰여진 batch 파일.
		: 쉘 스크립트는 맨 윗줄에 #!/bin/bash || #!/bin/sh 와 같이 해당 파일을 어떤 쉘로 해석할 수 있는지 지정해둔다.

	:  Linux에서 사용하는 Shell의 종류 >> bash , zsh , sh 등이 있다
		: Bourne Shell 쉘 
			: 경로 >>  /bin/sh 
		:  Bourne-Again Shell 쉘 
			: 경로 >> /bin/bash 

셸 세션 : 셸을 실행시킨 것. 셸과 셸 세션은 프로그램과 프로세스 느낌
	

docker 기초 명령어
    : 기본명령어 >> docker : docker 패키지를 사용하겠단 기본명령어
	: docker 패키지를 사용하는 것이므로, docker 패키지가 설치된 host 쪽에서 사용가능한거다. "docker" container 라고 docker container 에서 사용 가능한게 아니라 (물론 그 컨테이너에 docker 패키지가 설치되어있으면 가능하긴 하겠지만.. 일반적으로... )
 
    : 하위 명령어
	: image >> 이미지에 대한 작업을 하겠다 
	    : pull >>   원격으로부터 특정이미지를 로컬에 다운로드 받겠다
		: 인수 ) "이미지명:태그명"
			: docker hub 가면 명령어 코드 다 써있고 걍 그거 복붙하면 된다.
			: 태그명은 버전이라고 봄 된다.
			: 태그명을 명시하지 않을 시 디폴트로 "latest" 가 적용된다.
				: 주의 >> 실제로 "latest" 라는 태그가 따로 있다. 버전 중 가장 최신 버전을 매치 시켜주겠다는 말이 아니다.

		: 출력되는 내용 ) 
			(1) "Using default tag: latest" 
				: 태그명을 명시하지않으면 이 문구가 나온다. (명시하면 안나옴)

			(2) "latest : pulling from library/이미지명" 
				: 해당 이미지를 원격저장소의 library/이미지명 에서 pull 을 받겠다. 

			(3) "이미지레이어다이제스트 : pull complete"
				: 해당 이미지 "레이어"가 성공적으로 다운로드 되었다. 
 					: 이미지레이어 >> 도커 이미지의 "특정" 레이어. 도커 이미지의 일부.
				: 이미지 레이어가 다운로드 될 떄마다 출력된다.
				: docker hub 에 나오는 해당 이미지의 수보다 더 적게 이 문구가 출력될 수도 있는데 , 이는 정상적인거다. 이미 존재하는 레이어일 경우 또 다운받지 않고 재사용하게 되어있기 떄문이다.

 
			(4) "Digest: 이미지다이제스트"
				: 이미지다이제스트 >> sha256기반으로 구해진 해당 도커 이미지 "자체"의 고유식별자
				:다이제스트 값으로도 해당 이미지를 똑같이 다운받을 수 있다 >> "docker image pull 이미지명@sha256:이미지다이제스트값"

			(5) "Status : Downloaded newer image for 이미지명: 태그명"
				: "이미지명: 태그명" 의 다운로드가 성공적으로 완료되었다

			(6) "docker.io/library/이미지명:태그명"
				: 다운로드 완료된 이미지의 URL


	    : push >> 레지스트리로 이미지를 업로드한다


	    : rm >> 특정 이미지를 삭제한다.
		: 인수로 이미지 ID  줘야된다


	    : ls >> 로컬에 다운로드된 이미지 목록을 확인하겠다
		: 출력되는 내용 ) 	
			1. REPOSITORY
			2. TAG
			3. IMAGE ID << pull 할 때와는 다르게 IMAGE DIGEST 가 나오는게 아님 주의
			4. CREATED
			5. SIZE


	    : tag >> 이미지 태그를 생성

	    : build >> Dockerfile 로 부터 이미지를 build 한다

	    : import >> 이미지 생성을 위해 tarball 콘텐츠를 불러온다.
	    : load >> tarball 로 묶인 이미지를 로드
	    : save >> 이미지를 tarball로 저장





	: container >> 컨테이너에 대한 작업을 하겠다 
	    : tip
		: run VS start VS create		
			: create >> 특정이미지로 컨테이너를 새로 생성하고, 따로 실행시키진 않는다
			: start >> 종료된(=생성된적있는) 컨테이너를 시작한다. 
			: run == start + create >> 특정이미지로 컨테이너를 새로 생성하고, 실행시킨다.
		: https://yooloo.tistory.com/40

	    : run >> 특정이미지의 컨테이너를 "새로" 생성 및 실행하겠다
	        : 추천 형식 >> docker run -it --name 컨테이너명 --net 네트워크모드명 [이미지명]
	        : 형식 >> docker run [옵션] [이미지명]
			: 필수 인수 ) 실행하고자 하는 이미지명
			******: 주의 >> 태그까지 명시해야된다. 안그럼 내 의지와 상관 없이 "latest" 가 적용된다.
	
			: 옵션 >> 습관적으로 걍 -it 사용해라
				(1) 안줌 : 단순 실행시킴
					: 출력결과 ) 딱히 아웃풋이 뭔가 없다 

				(2) -i : interactive. 표준입력(STDIN) 을 열어두어, 사용자로부터 입력을 받을 수 있게 한다.
				(3) -t : tty. 가상터미널을 할당한다. 입력되는 명령어를 실행시킨다. 
					: 주의 >> -t 를 쓰면 입력되는 명령어를 실행시킬 수 있지만, 표준입력까지 알아서 제공해주지 않는다. 따라서 사용자로부터 입력 받은 명령어를 수행시키고 싶으면 -i 옵션과 함께 써야된다.
				(4) -d: detached mode 로 실행시킨다.(백그라운드모드)


				(5) -e : 환경변수 설정
					: postgres 같은 db 이미지 run 시, pw 설정등을 위해 필요한 듯


			 : 유용한 옵션 세트
				(1) -it : 컨테이너 내부에 들어가고 싶을 때 사용.
					: 의미 >> 현재 가상 터미널에서, 키보드 입력을 컨테이너에게 전달하고 그 결과를 출력하여 해당 컨테이너와 상호작용하겠다.
					: 결과 >>
						1. 사용자 이름과 호스트 이름이 바뀐다.
							사용자는 >> root 로
							호스트이름은 >> 컨테이너 ID

					: 컨테이너 밖으로 나오는 법 == 해당 컨테이너 종료하는 것
						sol1 ) 걍 exit << 개추
						sol2 ) docker container stop 컨테이너ID

			: 사실 run 은 container 이란 명령어 없이 바로 "docker run" 만 써도 되긴 하는데, container 라는 하위명령어를 명시하는게 권장된다.
			: 기본적으로 attached mode 로 실행된다. 즉, 현재 터미널 세션을 해당 container 에게 할당한다. foreground 에서 실행된다.



	    : pause >> 해당 컨테이너 내부의 "모든" 프로세스를 정지시킨다
	    : unpause >> 멈춰있던 프로세스를 재실행시킨다


	    : stop >> 실행중인 컨테이너를 종료하겠다. (== 종료 )
 		: 인수로 컨테이너Id || 컨테이너 name  를 줘야된다

	    : kill >> 실행중인 컨테이너를 "즉시" 종료하겠다. (== 강제종료 )
		: 인수로  컨테이너Id || 컨테이너 name  줘야된다
		: stop 보다는 효율성이 떨어진다.

	    : restart >> 실행중인 컨테이너를 종료했다가 다시 실행시키겠다. (== 다시시작 )

	    : start >> 종료된 컨테이너(=이미 run 된적있는컨테이너)에 다시 접속하겠다. 
		: 기본적으로 detached mode 로 실행된다. 즉, background 에서 컨테이너가 실행된다
		: 주의 >> 이유는 모르겠는데 run 명령어로 컨테이너 생성 당시 -it 옵션을 함께 주지 않았던 경우, 이후 start 명령어로 재실행시켰을때 해당 컨테이너가 바로 종료된다. -it 옵션을 함께 주었던 경우만 start 이후에도 바로 종료되지 않아 attach 같은걸 적용가능했었다.

	    : attach >> 현재 "실행중인" 컨테이너 대해 내부 접속(== 터미널 세션에 연결)하겠다. 
		: 그러니까 start 명령어가 선행된 이후에 사용가능한거다
		: 인수로 "컨테이너 Id || name"  줘야된다


	    : exec >> 현재 "실행중인" 컨테이너의 외부에서 명령어를 실행함
		: 옵션 -it 
			:  attach 와 유사하게 표준입출력까지 연결하여 내부에 들어간 것 처럼 사용하고 싶으면, run -it 처럼 exec -it 롤 함 된다
			:  -it 없이는 단순 백그라운드에서 명령어를 실행시킨다.

		: 인수로  "컨테이너 Id || name" , "command"룰 줘야된다
			: 그러니까  docker container exec [옵션] [컨테이너Id || 컨테이너name] [ command ] 
			: attach 와 다르게 직접 COMMAND 를 설정 가능하여 , 실행 시킬 셸을 지정가능
		


		: exec VS attach >> 둘다 (실행중인) 컨테이너에 명령어를 실행시킴. 
		     : 컨테이너의 주 프로세스는 대부분 /bin/bash 와 같은 터미널 기반의 명령어이고, 이를 통해 터미널 세션이 생성 및 연결된다

			: exec >> 컨테이너 외부에서 접근해 명령어를 실행시킨다. 
				: 새로운 프로세스를 생성하여 독립적인 세션에서 작업을 수행 >> 즉, 터미널 세션을 새로 생성해 연결한다. 
					: docker exec -it <container_id> /bin/bash 가 겉보기엔 docker attach <container_id> 와 다를게 없어보여도,  exec -it는 새로운 세션을 생성하여 현재 세션에 연결시켜주는거고 attach 는 걍 현재 세션에 연결시켜주는거란 점에서 서로 다른거다. 
						: 둘이 다른 걸 단적으로 알 수 있는 예시 >> docker exec -it <container_id> /bin/bash 하고 "exit"을 해도 해당 컨테이너는 종료가 안되지만  docker attach <container_id> 하고 "exit"하면 해당 컨테이너는 종료가 된다.
							:  docker attach <container_id> 하고 "exit" 했을 때 주 프로세스가 종료되고, 컨테이너는 주 프로세스의 시작/종료와 함께 시작/종료되기 때문에 해당 컨테이너도 종료가 된다.

				: cd 명령어는 수행시키지 못한다.
				: 디버깅 용도, 추가적인 작업 수행 용도로 주로 사용


			: attach >> 컨테이너 내부에 접속해 직접 명령어를 작동시킨다.
				: 기존 주 프로세스에 연결하여 동일한 세션에서 작업을 수행 >>  즉, 현재 터미널 세션에 연결.


	    : cp >> 컨테이너 <---> 호스트 간 파일 전송
		: 주의 >> 컨테이너에서 호스트로건 , 호스트애서 컨테이너로건 이 명령어는 무조건 (컨테이너 쪽이 아닌) 호스트 쪽에서 실행되는거다 : 생각해보면 당연한게, "docker container cp" 는 도커 명령어로, 도커가 설치되어있어야 실행 가능한 명령어다. 컨테이너 내부에는 일반적으로 도커가 설치되어있지 않으므로 호스트 쪽에서 해줘야된다.
		: docker container cp [파일제공해주는경로1] [파일제공받는경로2]
		    : 일반적인 cp 명령어랑 ㅈㄴ 비슷한데 "컨테이너:/" 를 명시하는 것만 좀 다른 것
			: 호스트의 파일을 특정 컨테이너로 >>  docker container cp [호스트의파일의경로] [해당컨테이너명:/해당컨테이너의특정폴더경로]
			: 특정 컨테이너의 파일을 호스트로 >>  docker container cp [해당컨테이너명:/해당컨테이너의특정파일경로] [호스트의특정폴더경로] 


	    : rm >> 특정 컨테이너를 삭제한다.
		: 인수로 컨테이너Id || 컨테이너 name  줘야된다
			: 인수로 여러개의 컨테이너 Id || name 주면 한번에 삭제 가능하다.


	    : commit >> 해당 컨테이너를 이미지로 저장한다. 
		: 인수로 "수정이반영된컨테이너 Id || name", "새로운이미지명" 을 줘야된다
			: 그러니까  docker container commit [컨테이너Id || 컨테이너name] [ 새이미지명 ] 
	    : update >> 해당 컨테이너의 설정 업데이트
	    : export >> 컨테이너 파일 시스템을 tarball 로 추출
	    : inspect >> 해당 컨테이너의 상세 정보 표시
	    : diff >> 컨테이너 파일 시스템의 변경 내용 검사
	    : port >> 특정 컨테이너에 맵핑된 포트 리스트를 확인한다
	    : top >> 컨테이너의 실행중인 프로세스 표시
	    : stats >> 컨테이너 리소스 사용 통계 표시
	    : logs >>현재 "실행중인" 도커 컨테이너의 로그를 불러온다.
	    : ls >> 현재 "실행중인" 도커 컨테이너 목록을 확인하겠다.
		: "docker ps" (Process Status) 로도 이와 동일한 기능을 수행할 수 있는데, 그건 좀 구식이고 요즘엔 ( 명령어를 일관적으로 하기 위해 ) 이렇게 쓴다. 
		: 출력결과 ) 	
			1. CONTAINER ID 
			2. IMAGE 
			3. COMMAND : 해당 컨테이너가 실행할떄, 함께 실행되게 설정된 주 프로세스(의 경로)
				: 개발자가 따로 만질 필요는 없음
				: 주 프로세스 >> docker container 가 시작될 떄 가장 먼저 실행되는 기본 프로세스로, 컨테이너의 시작/종료와 함께 시작/종료된다.
					: 주 프로세스와 터미널 세션 
						: 주 프로세스가 터미널 기반의 명령어(예: /bin/bash)일 경우, 이를 통해 사용자가 명령어를 입력하고 실행할 수 있는 터미널 세션이 생성됨


			4. CREATED : 컨테이너가 생성되고 난 뒤 흐른 시간
			4. STATUS  :
				: 3가지중 하나로 출력됨
					UP : 실행중인 상태
					PAUSED : 중지 상태  
					EXITED : 종료 상태
						: EXITED( 0 ) >> 정상 종료됨

			5. PORTS: 포트 포워딩, 호스트 포트와 컨테이너 포트의 연결 관계
			6. NAMES  : 컨테이너의 이름

		: 옵션
			(1) 안줌 : 실행 상태의 컨테이너만 출력됨
			(2) -a : all. 실행 상태, 정지 상태의 컨테이너를 모두 출력


도커의 작동 방식
	1. 도커 클라이언트에서 (이미지를 다운받는) 명령어를 입력 : docker image pull [이미지명:태그명]
	2. 도커 호스트의 데몬이 해당 명령어를 받고 해당 이미지가 존재하는지 확인
		case 1, 도커 호스트에 해당 이미지가 존재하지 않으면, "도커레지스트리"에서 해당 이미지를 다운로드 받음  
			ex ) hello-world 이미지가 다운로드되있지 않은 상황에서 "docker container run hello-world" 의 작동 과정
				1. docker container run hello-world 명령어 입력
					: docker >> docker 패키지를 사용하겠단 기본명령어
					: container >> 컨테이너 대한 작업 하겠다.
					: run >> 컨테이너를 실행하겠단 하위 명령어
					: hello-world >> 컨테이너 이름

				2. 출력됨
					(1) "unalbe to find image 'hello-world:latest' locally" 
						: 로컬에서 hello-world 를 찾을 수 없다. 해당 이미지가 다운로드 안되어있다.
					(2) "latest : pulling from library/hello-world" 
						: 해당 이미지가 다운로드 되어있지 않으니 library/hello-world 에서 pull 을 받겠다. 
					(3) "이미지레이어다이제스트 : pull complete"
					(4) "Digest: 이미지다이제스트"
					(5) "Status : Downloaded newer image for hello-world: latest"
						: hello-world: latest 의 다운로드가 완료되었다


		case 2. 도커 호스트에 해당 이미지가 존재한다면
			ex ) hello-world 이미지가 다운로드되있는 상황에서 "docker container run hello-world" 의 작동 과정
				1. docker container run hello-world 명령어 입력
				2. (따로 뭔가 출력되진 않고) 로컬에 있는 이미지가 실행된다




------------------------------------------------------------------------------------------


ping Packet INternet Grouper :  일정한 크기(32바이트)의 패킷을 특정 네트워크로 보내, 네트워크가 정상적으로 동작하는지 점검하는 것


host : 네트워크/인터넷에 연결된 장치
	: https://lxxyeon.tistory.com/172

LAN Local Area Network : 근거리 통신망. 로컬 네트워크.
Ethernet : LAN 환경에서 대부분을 차지하는 네트워크 구성 방식
WAN Wide Area Network : 원거리 통신망
 

MAC 주소 : NIC 를 가진 단말에게 부여되는 주민등록번호와 같은 고유한, 물리적인 주소
	: NIC Network Interface Card>> 컴퓨터 등의 기기가 인터넷에 연결되게끔 도와주는 부품.랜카드 라고도 함.
	: LAN 에서는 IP 주소를 MAC 주소에 매칭하는 방식으로 통신이 이루어진다
		: 그러니까 목적지는 IP 주소값으로 지정하고, 해당 IP주소값에 바인딩된 MAC 주소 값을 가지는 단말로 찾아가는 방식의 통신이라는것 
		: IP 주소는 논리적이고 가변적이지만 MAC 주소는 물리적이고 불변적이다.
		: IP 주소의 사용 없이 고유한 MAC 주소만을 일일이 라우팅 테이블에 등록했다간 그 값이 ㅈㄴ 많아져서 라우터가 다운되고 말 것.


ARP Address Resoultion Protocol : IP 주소를 MAC 주소와 매칭시키기 위한 프로토콜
	: ARP 통신 과정
		1. ARP Request >> (LAN 구간의 모든 호스트에게 전달해야하므로) Broadcast 통신으로 해당 IP를 가지는 MAC 주소 정보를 요청하는 패킷을 보낸다.
		2. ARP Response >> ARP Request 를 받은 호스트가 해당 IP를 가지고 있으면 자신의 MAC 주소를 담은 패킷을 (요청한 특정 호스트에게만 전달하면 되므로) Unicast 로  응답한다.
			: ARP Request 받았는데 해당 IP가 자신의 IP가 아닌 경우 해당 호스트는 그 패킷을 걍 읽씹하는거임

			: 그런데 매번 요청마다 이 과정을 반복하는건 좀 비효율적이므로, 한번 ARP 를 통해 얻어졌던 IP 주소 & MAC 주소 정보들은 "ARP Table "로 저장해둔다.
				: ARP table . MAC table .>> IP 주소와 MAC 주소를 1:1 매칭시킨 정보가 정리된 테이블


	: https://techjuny.tistory.com/entry/MAC-%EC%A3%BC%EC%86%8C%EC%99%80-ARP



LAN 은 어디까지가 LAN 인가 ? >> 동일한 IP대역 사용 + ARP request 가 전달될 수 있는 영역
	: https://aws-hyoh.tistory.com/85


라우터 스위치 허브
	허브 >> 전기적인 신호를 증폭시켜 LAN의 전송거리를 연장시키는게 목적. 충돌이 많다.
		: flooding >> 한 장비에서 전송된 데이터 프레임을, 허브로 연결된 모든 장비에게 다 전송함
		: half duplex >>전송의 방향은 양방향이지만 전송이 이루어지는 한 순간에는 양쪽 중 한 방향만으로 전송이 가능

	스위치 >> MAC 주소를 기반으로, 연결된 근거리 기기로 프레임을 전송함.
	라우터 >> 네트워크 대역 다른 장비들을 연결하기 위해 사용
	: https://sangbeomkim.tistory.com/157
	

네트워크 통신 과정 간단 요약 >> 같은 네트워크에 있는 컴퓨터들끼리는 Gateway를 사용하지 않고 switch 등을 통해 통신을 할 수 있지만 다른 네트워크를 찾아갈 경우에는 반드시 Gateway를 통해서 접속해야 한다
	1.컴퓨터 A가 컴퓨터 B에게 데이터를 전송한다.
	2. 데이터는 여러 개의 패킷으로 쪼개져서 전달된다. 각 패킷에는 출발지 IP와 목적지 IP가 써 있다
	3. 패킷은 회사 내부 네트워크의 로컬 라우터 || 스위치로 전달
	4. 라우터는 패킷에 써 있는 IP 정보를 확인하고 라우팅 테이블과 비교해 올바른 장치로 전달 >> 같은 네트워크에 속해있지 않은 경우 게이트 웨이로 전달, 게이트웨이는 해당 패킷을 외부 네트워크로 라우팅 
	5. .목적지 IP 장치에 도착한 패킷은 다시 하나로 조립됨
	: https://binwrite.com/network-communication/




서브넷 subnet : sub + network . (단순히 클래스로 분류하는게 아니라) 네트워크를 좀 더 잘게 분할한 것.
	: 서브넷팅 >> 네트워크를 분할 하는 것으로, "서브넷 마스크"를 통해 수행된다.
	: 서브넷 마스크 >> 해당 IP 주소의 어디까지 네트워크 주소인지 명시하는 값.
	    : 표현방법 
		sol1. IP 주소 뒤 슬래시 뒤에 , 네트워크 주소를 나타내는 비트 수로 표시
		sol2. 255.255.255.128 이런식으로 IP 처럼 표시됨

	: 사용 이유 >> 낭비되는 IP주소 자원 최소화



네트워크 대역 : (서브넷팅 같은거 다 고려했을 때) 사용 가능한 IP 주소 범위
	: 근데 실제론 네트워크 대역을 다 사용하진 못하고, 앞 뒤 두 개 뺀 범위에서 사용 가능하다.
		: 젤 첫 주소는 network 주소, 마지막 주소는 broadcast 주소 로 호스트 컴퓨터에 할당할 수 없는 IP 주소이다. 
		: https://m.blog.naver.com/kangyh5/223175392071

	: 게이트웨이 주소는 통상 사용 가능한 첫번째 주소로 지정한다
		: 네트워크 대역이 192.168.0.0 ~ 192.168.0.255 일 때 통상 게이트웨이 주소는 192.168.0.1 이다
		: 꼭 그래야되는건 아니다. 다른 아무런 주소 택해도 되는데 말 그대로 "관례적"으로 그렇다는 것.


같은 네트워크 대역 == 단순히 앞자리(서브넷마스크부분)가 동일한 IP 주소들. 
	: https://binwrite.com/ip-band/
	: 같은 대역은 통신이 되는 이유 >> 패킷을 보냈을 때 외부로 나갈 필요 없이 로컬 네트워크 안에서 인식됨.
		: 다른 대역의 경우 외부 네트워크로 가야하기 때문에 gateway 를 거쳐야한다




gateway >> 한 네트워크에서 다른 대역의 네트워크로 갈 때 반드시 거쳐가야하는 통로, 출입구. 
	: 라우터와 달리 게이트웨이는 장비가 아닌 개념 || IP 주소. 
	: gateway 가 IP 주소를 의미하는 경우, 라우터의 (공인IP 와 사설 IP 중) 사설 IP 를 의미
		: 출입구니까.
	: hop count >> 거치는 게이트웨이의 수 


라우터 router  >> 내부 네트워크와 외부 네트워크 연결 및 최적 경로(route) 결정해주는 장비
	: 라우터는 내부 ip 주소와 외부 ip 주소를 모두 가지며, 내부 ip 주소가 gateway 에 해당 
		: 참고로 내부 네트워크와 연결되는 IP 즉 gateway 는 Ethernet Interface, 외부 네트워크와 연결되는 IP는 Serial Interface 라고 한다.

	: LAN과 LAN을 연결하거나 LAN과 WAN을 연결해준다.
	: 공유기 가 대표적인 라우터.
	: routing >> 적절한 네트워크로 패킷을 전송하는 것



네트워크 주소 변환 NAT Network Address Translation 
	: 사설 IP 주소와 공인 IP 주소를 변환해주는 "기능".
		: 사설 IP 주소로는 원칙적으로 외부와 통신할 수 없기 때문에 이를 공인 IP 주소로 중간에 변환해 주어 외부와 통신(인터넷 연결) 할 수 있게 해주는 것
		: 특정 한 장비를 지칭하는게 아니라 그러한 기능, 프로그램을 의미 >> 라우터 등에 NAT 기능이 포함되어있다

	: 사용 목적
		1. 공인 IP 절약
		2. 외부망으로부터 사설망 보호


bridge>> 내 컴터를 하나의 다리 bridge 로써 사용하는 방식. 가상머신 컴퓨터의 네트워크 어댑터와 호스트 컴퓨터(= 내 실제 컴터)의 네트워크 어댑터를 연결시켜,  게스트 네트워크(가상머신의 네크워크)가  호스트 네트워크(내실제컴터 네트워크)와 동등한 수준의 네트워크를 제공받게 되는 것. 
	: https://onestone-note.tistory.com/10
	: https://itmore.tistory.com/entry/NAT-%EC%99%80-Bridged-Networking-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC



포트 >>  컴퓨터의 Lan선은 하나인데, 통신을 필요로 하는 프로그램이 다수일 때 이 다수의 프로그램을 구별할 수 있는 번호

포트 포워딩 port forwarding  : 포트를 활용하여 , 외부망에서 내부망의 특정 PC를 찾아갈 수 있도록 해주는 것. "공인아이피:포트번호" 와 "사설아이피:포트번호"를 매핑해주는 것.
	: 내부망에서 게이트웨이를 통해 외부망으로 나가는건 쉽지만, 외부망에서 내부망으로 들어오는건 쉽지 않은데 이를 가능하게 하는 것이 포트 포워딩이다.
		: 외부망에서 내부망으로 들어오는게 쉽지 않은 이유 >> 사설 IP는 공인IP 처럼 특정 기기를 가리키는게아니라, 여기저기서 사용되기 때문.
	: 내부망의 컴퓨터가 n 번 포트 쓴다고 라우터에서 자동으로 n번 포트를 해당 컴퓨터에게 바인딩 시켜주는건 아니고, 사용자가 직접 해당 컴퓨터가 어떤 포트와 바인딩될지 설정해야됨.
		: 참고로 외부포트와 내부포트는 같을 필요 없다
			: 2525 포트를 5252 포트로 포워딩 가능

		: 참고로 하나의 포트로 들어오는 연결을 두 아이피로 포워딩 불가능하다

	: https://sangbeomkim.tistory.com/105




도커 네트워크 >>  "호스트 머신 내부서 컨테이너 간" || "콘테이너와 외부 간" 자원을 공유할 수 있게 하는 것
******: https://rimo.tistory.com/27
	: https://bluese05.tistory.com/15
	:https://velog.io/@whattsup_kim/Docker-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC

	
 
	: "컨테이너 - 컨테이너 간의 통신" 과 "컨테이너 - 호스트 간의 통신"




	: 도커 자체에선 여러 네트워크 드라이버를 제공. 일종의 모드라고 봄 됨
		1. bridge >> 컨테이너에 임의의 새로운 내부 IP 를 할당하여 네트워크를 구성하는 모드
			: 이게 docker0 같은거 쓰는 방식으로, 디폴트다.
			: docker run 으로 컨테이너를 생성할 때 연결될 브리지를 지정 가능
				docker run -it --name 컨테이너명 --net 브리지명 이미지명
				: 특정 브리지를 명시해주지 않으면 기본적으로 docker0 브리지에 연결된다. 
	
			: 새로운 브리지를 생성할 수도 있다.
				docker network create --driver bridge 새브리지명

			: 생성한브리지 상세정보출력
				docker inspect 브리지명

			: 같은 브리지를 공유하는 컨테이너끼리는 통신이 쉽게 가능하고(같은 대역대의 통신), 다른 브리지에 속한 컨테이너끼리는 그냥은 불가하다.
			

			: 컨테이너는 각자 독립된 네트워크 공간을 할당받는다.
				: 각 브리지 내의 컨테이너마다 "내부IP"가 도커에 의해 순차적으로 할당됨
					: 다른 브리지의 컨테이너들은 대역대가 다름
					: 내부 IP는 고정이 아님. 재실행할 때마다 바뀔 수 있음
				: 내부 IP만으로는 외부와의 통신이 불가하고, 이를 위해 인터페이스들이 필요한 것
 				: inspect 헸을 떄 나온 "IPAddress" 할당된 내부 IP다.



		2. host >> 컨테이너에 새로운 내부 IP 가 아닌, host 컴퓨터와 동일한 네트워크 환경을 사용하게 하는 모드
			: 결국 호스트 내에서 애플리케이션을 실행한 것과 같아진다.
			: run 할 때 host 모드를 사용하겠다고 지정해줌 된다
				docker run -it --name 컨테이너명 --net host 이미지명
			: when 사용 >> NAT 과정을 생략하므로써 성능 향상 및 최적화가 필요할 때 사용할 수 있으나, 컨테이너에 보안 문제가 발생하면 호스트 네트워크까지 직접적으로 문제가 발생하므로 주의해야된다.

		3. none >> 아무런 네트워크를 사용하지 않는 모드. 어떠한 외부와도 연결할 필요가 없을 때.
			: run 할 때 none 모드를 사용하겠다고 지정해줌 된다
				docker run -it --name 컨테이너명 --net=none 이미지명
			: none 드라이버를 활용하면 컨테이너를 대상을 ifconfig 했을 때 eth0 이 없는 것을 확인 가능 ( lo만 있다 ) 



	: 핵심 인터페이스	
	    : 컨테이너가 생성될 때마다, pair interface || peer interface 가 함께 생성된다
		: pair interface , peer interface >>  eth0 이라는 인터페이스와 vethXXXX라는 인터페이스의 쌍을 일컫는 것으로, eth0은 컨테이너 내부에 생성되지만 vethXXXX는 호스트영역에 생성됨을 주의.


	    : 호스트(==우리 )<< 걍 일반사용자권한에서 ifconfig 함 확인 가능
		-1. enp0s3 , eth0 >> 호스트의 NIC. 호스트가 외부와 통신할 수 있게 해준다.
			: 옛날엔 eth0, eth1 이런 식으로 썼는데 요즘엔 순서 예측등이 어렵다는 이유로 enp0s3등으로 쓴다.
			: 컨테이너의 eth0 과는 다른거임 주의
			: https://wjddn407.tistory.com/27

		0. vethXXXX >> 각 컨테이너를 시작할 때마다 도커엔진이 "호스트 쪽"에 자동으로 생성시켜주는 가상 네트워크 인터페이스로, 각 컨테이너에 외부와의 네트워크를 제공하기 위함.
			: Virtual ETHernet 
			: veth 인터페이스는 docker0 에 의해 호스트의 enp0s3(eth0) 과 연결된다.
			: 쉽게 생각하면 실행중인 컨테이너들 마다 1개씩 붙어있는 인터페이스라고 봄 된다.

		1. docker0 >> (호스트의) eth0 과 (호스트의) vethXXXX를 이어주는 인터페이스.
			: 도커 자체 제공 Bridge 네트워크
			: 일반적인 interface 가 아닌, virtual ethernet "bridge"	
			: 외부와 통신할 경우 docker0 이 gateway 의 역할을 수행
				
				
			

	    : 컨테이너 (내부)
		1. eth0 : 컨테이너의 NIC. 컨테이너가 외부와 통신할 수 있기 해준다.


	: 호스트 <--> 컨테이너 간 파일 전송 >> docker container cp 명령어 활용
		: 실습에서는 터미널 2개 열고, 터미널 하나는 host 전용, 나머지 하나는 컨테이너 내부 전용으로 사용한다	
		: 어느 방향이건 해당 명령어는 호스트쪽에서 실행되어야함
			:호스트쪽에 docker 패키지가 설치되어있으니까


------------------------------------------------------------------------------------------




도커 스토리지 >> 도커 컨테이너에서 생성되는 데이터를 영구 보존하기 위해 사용
	: 필요성 
		: 
	: (도커 스토리지 없이 그냥은) 도커 컨테이너가 삭제되면, 컨테이너 내부의 파일도 함께 사라진다. 
	: 도커 스토리지의 종류 << 이후 챕터서 자세히 알아본다.. 
		1. bind mount : 도커 호스트 디렉터리를 직접 공유하는 방식
		2. volume : 도커를 활용해 볼륨을 생성한 후 컨테이너의 디렉터리를 직접 공유하는 방식
		3. tmpfs : 도커 호스트 메모리에 파일이 저장되는 방식
			: 컨테이너를 삭제하면 해당 파일도 함꼐삭제됨


PostgreSQL : 데이터베이스의 한 종류
	: 이미지 실습
	: 명령어
		: psql 명령어를 제외한 모든 db 쿼리스러운 명령어(?)는 ";"로 끝나야된다
			: 안그럼 엔터쳐도 해당 문장이 다 안끝났다고 인식한다

		: 기본명령어 >> "psql" 
			: 처음에 postgreSQL 에 로그인할 때 "psql -U postgres" 이런식으로 한다. 

		: 사용자. ROLE 생성 >> CREATE USER [사용자명] PASSWORD ['비번'] [권한];
			: 권한으로는 SUPERUSER 등 가능

		: DATABASE 생성 >> CREATE DATABASE [db명] OWNER [사용자명];
			: 스키마 생성하는거라고 봄 된다.

		: 생성한 DATABASE 에 접속 >> [db명] [사용자명]
			: 
