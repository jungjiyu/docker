도커 기초 지식
	- 도커의 구성 요소, 작동방식
	- 컨테이터로 실행하는데 필요한 내용 학습
	- 관련 명령어
	- 도커 네트워크, 스토리지

------------------------------------------------------------------------------------------

apt install 할 때, 항상 apt update 를 먼저해라. 
	: 그래야 기존 설치한 패키지들이 최신 상태로 유지되서, install 할 때 의존성 패키지도 최신 버전으로 설치되서 좀 관리하기 편하다.

alt + F2 ,F3 ...  누르면 새로운 터미널 열 수 있다 !!
	: 인터넷의 다른건 해봤을 때 안먹혔다
	: 특정 터미널로 이동하고 싶을 땐 "alt + 해당Fn" 누름 된다 


architecture 
	: cpu 의 종류를 의미.
	: 대표적인 architecture
		: intel 기반 >> 현존하는 "pc 프로그램" 대부분이 이 아키텍처를 지원
			1.  x86 >> 32 bit 기반 cpu 
			2.  amd64(= x86_64) >> 64 bit 기반 cou
				: 사실 완전 intel 기반은 아니고, 하위 호환 개념. 쩄뜬 잘 작동한다. 

		: arm 기반 >> "모바일 앱"이 이 아키텍처를 지원
		    : pc 프로그램의 경우 linux 와 mac 은 arm 을 지원하지만, windows 는 지원을 안함
			1. arm >> 32 bit 기반 cpu
			2. arm64 >> 64 bit 기반 cpu

	: 애플리케이션, 라이브러리가 실행될 서버의 아키텍처를 알아야하는 이유 >> 애플리케이션은 결국 "사전 컴파일"된 바이너리( 라이브러리도 대부분 사전 컴파일되어 제공된다 ). 이때 이 컴파일을 어떤 CPU 로 했느냐 따라 결과물이 달라진다.  intel 기반 cpu 로 빌드한 애플리케이션을 그냥 arm 기반 cpu 로 가져오면 실행이 안된다. 
	: 도커 이미지 같은 경우도,  pull 받을 때 그 머신의 CPU에 따라 맞는 아키텍처를 받아야된다.
		: docker hub 가보면 x86-64 , arm64 등 따로 구분되어있다  
	: https://velog.io/@480/%EC%9D%B4%EC%A0%9C%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%8F%84-CPU-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%A5%BC-%EA%B5%AC%EB%B6%84%ED%95%B4%EC%95%BC-%ED%95%A9%EB%8B%88%EB%8B%A4





하위 명령어
	: 리눅스에서 기본 명령어 다음에 하위 명령어가 올 수 있다. 
	: 각 하위 명령어는 일반 명령어와 마찬가지로 옵션 과 인수를 가질 수 있다.
		: ex ) docker run hello-world , docker pull ubuntu
	: 하위 명령어와 인수를 구별하는 tip
		: 하위 명령어는 보통 특정 작업을 지칭하는 동사형이다.
			: 사실 걍 보면 아 이새끼는 인수가 아니구나 라는 느낌이 온다
		: 인수는 보통 특정 자료 같은 명사형이다 .




digest : 해시함수 산출값.
	: DIGEST vs ID >> 모두 식별자 개념
		: digest 는 찐으로 고유한 느낌 >> docker 에서 digest 는 push 될 때 결정되고, pull 이 어디서 되건간에 항상 그 값을 유지한다.
		: id 는 환경적.지역적으로 고유한 느낌 >> docker 에서 id 는 pull 되는 환경에서 , 도커가 내부적으로 사용하는 식별자. (캐시등에서 활용하기 위해)


매니페스트 manifest : 어떤 것에 대한 명단. 목록.
	: 영단어 뜻 자체로는 "화물 목록" 이다.
	: https://bsnippet.tistory.com/7


tarball :  ".tar" || "".tar.gz" 파일을 일컫는 전문 용어
	: ".tar" 확장자여서 tar + ball 이라고 하는 듯?
	: .gz 는 해당 파일을 압축시킨 파일이다


Dockerfile : 뭐 이후 챕터에 나오는 것 같은데 이건 그때 정리
	: https://seosh817.tistory.com/381


(일반적인) 이미지 : 물리적인 광매체(cd, dvd 등)를 압축한 파일. 
	: 광매체에 이미지라는 표현을 많이 쓰다보니 이미지 파일이라는 이름이 붙여진것
	: 다운로드/저장/백업 용으로 쓰인다.
	: 굳이 광매체를 압축해서 이미지로 만든 건 일일이 CD 같은거 들고다니기 귀찮으니까.
	: https://blog.naver.com/taeho930/220488967313 



도커 이미지 image : 컨테이너 형태로 소프트웨어를 배포하기 위해, 필요한 모든 파일을 포함하는 패키지.
	: 모든 도커 컨테이너는 도커 이미지를 기반으로 생성된다.
	: debain OS 에서 apt install 을 하면 기본적으로 apt 레파지토리에서 패키지를 내려받듯이 도커는 기본적으로 docker hub 에서 이미지를 내려받는다.

	: 구조 >> 효율적 사용을 위해 레이어 구조로 이뤄짐.
		: 도커 이미지는 컨테이너를 실행하기 위한 모든 파일을 가지고 있기에 용량이 크다.( 수백 MB )
			: (이미지를 수정없이 계속 사용한다면 별 문제 없겠지만) 이미지에서 파일 하나를 수정한다고 했을 때, 기존이미지를 또 다운 받아서 처음부터 세팅 다 다시하고 새로운 내용을 받아야된다면 매우 비효율적일 것. >> 이러한 문제 해결을 위해 도커 이미지는 레이어 구조로 이뤄짐

		: 여러개의 read only (읽기 전용. 수정 불가)레이어 로 구성되고, 파일이 추가되거나 수정되면 새로운 레이어가 생성됨 >> base layer(기존 layer들)은 변경 필요 없이 새로운 layer 를 추가만 하면됨
			: read only 이기 때문에 파일을 추가할 때 뿐아니라, 수정할 때에도 새로운 layer 가 추가된다
			: 이미지는 read only 이기에 특정 시점의 도커 컨테이너의 상태를 담은 "스냅샷"이라고 볼 수 있다.
				 : 특정 시점의 상태를 사진 찍어둔 것처럼 그대로 저장해둔 것이니까. 
			: 이미지 자체는 읽기 전용이기에 실행이 불가하다.
			: 동일한 환경을 가진 컨테이너를 마음껏 생성 가능하게 해준다


		: 이미지를 pull 시키면 해당 이미지의 레이어 단위로 차곡차곡 pull 된다.

	

	: 용어
	    : REPOSITORY >> 특정 도커 이미지 자체
		: ex) python , ubuntu
  	    : TAG , INDEX >> 특정 도커 이미지의 특정 버전
		: ex) python:3.9.19 에서 "3.9.19"
	    : MANIFEST >> 도커 이미지의 특정 아키텍쳐. 
		: ex) python:3.9.19 의 amd64 버전
		:"config" + "layer들". 다양한 환경에서 해당 이미지를 활용할 수 있도록. "특정 config" 와 "레이어들"을 제공. 
			: config >> 해당 이미지가 어떻게 만들어졌고, 어떻게 실행 가능한지 등에 대한 메타데이터가 들어있다
			: 이미지 "매니페스트" 라고 부르는건, 여러 레이어들을 포함하는 개념이라. 레이어들의 목록이라 그런 것 같다.


	    : DIGEST
		: INDEX DIGEST >>  "태그"에 대한 식별자
			: SHA256 해시 값을 사용하여 생성된 값으로, 해당 이미지가 도커레지스트리에 push 될 때 결정된다. (매번 pull 받을 때마다 새롭게 구해지는게 아니다)
			: when 사용
				: 이미지가 변경되지 않았음을 보장하는 데 사용
				: 각 이미지를 식별하기 위해 사용
			: docker hub 에서 확인 가능하다 <-- index digest 옆에 표기되어있다
			: docker image pull 할 때도 확인 가능하다 <-- 끝쪽 부분에 "Digest : ... " 으로 출력된다.			

 		: MANIFEST DIGEST >> "아키텍쳐"에 대한 식별자
			: 특정 태그의 도커 이미지의 특정 아키텍쳐를 의미
				: 그러니까 마냥 amd64과 같은 아키텍쳐에 대한 식별는 아니고, "python:3.9.11" 과 같은 특정 태그의 도커 이미지 중 아키텍쳐가 amd64 인것을 의미한다.
 
 		: LAYER DIGEST >> "레이어"에 대한 식별자
			: 특정 아키텍쳐의 특정 태그의 도커 이미지의 특정 레이어를 의미
			: docker image pull 할 때도 확인 가능하다 <-- 앞부분에 "  ... : Pull complete" 으로 출력된다.			
	
	    : ID
		: IMAGE ID >> 다운로드한 도커 이미지에, 로컬에서 부여한 ID값.
			; 로컬에서 이미지 대한 작업 (삭제 등) 할 때 사용된다.
			

	: 기존 이미지를 수정하여 새로운 이미지로 저장하기
	    : https://gracelove91.tistory.com/111
	    : 주의 >> 이미지를 수정/생성하는 과정이지만, 이미지자첸 read-only 라 이미지적으로 작업하는 내용이 없어, 이 과정서 하위 명령어는 "image" 가 아닌 "container" 이다. 
		: 원본이미지를 실행시켜만든 컨테이너로 다양한 수정작업을 수행하더라도, 바뀌는건 해당 컨테이너지, 이미지가 아니다. 해당 원본이미지를 기반으로 또 docker container run 수행시키면, 수정이 반영되지 않은 형태로 실행된다. 변경을 가한 컨테이너id를 기반으로 docker container start 를 해야지만, 변경된 내용이 적용된 형태로 실행시킬 수 있다. 이를 아예 base 이미지로 저장하여, 이를 디폴트로 컨테이너를 만들 수 있게 하고 싶을 때 commit 이란 작업을 수행하는 것이다.

		1. 일단 원본 이미지를 기반으로 생성된 컨테이너에 내부 접속한다	
			: 그냥 실행시키면 어케 반영할껀데? 들어가야지 뭘 할꺼아냐 
		2. 해당 컨테이너를 수정한다. (새로운 패키지 다운받던지 뭘 없애던지...)
		3. 해당 컨테이너를 커밋한다.  이떄 새로 생성될 이미지의 이름을 정해준다.
			: docker container commit [컨테이너Id || 컨테이너name] [ 새이미지명 ] 
				: 그러니까 현재 컨테이너를 기반으로, 새로운 이미지를 생성하는거다.


	: 도커 레지스트리에 저장되어 관리된다.
	: 일종의 템플릿이라고 볼 수 있다.
	: 독립적이라 의존성 고려 필요 없음
	: https://seosh817.tistory.com/377



(통상적인) 데몬 Daemon >> 백그라운드 프로세스. 밑에서 돌아가는.
도커 데몬 >> 도커 관련 작업을 하는 백그라운드 프로세스




도커 컨테이너 container : 도커 이미지를 실행할 수 있는 인스턴스 instance .
	: 도커 이미지로부터 생성된다. 
	: 특정이미지를 기반으로 컨테이너를 생성하는 과정
		step1. 컨테이너가 실행될 떄, 도커이미지가 이미지 레이어 형태로  복사된다. 이 이미지 레이어들은 도커 이미지에서와 마찬가지로 read-only 이다 >> 이미지 베이스(복사된 이미지 레이어들)은 수정 불가이다.
		step2. 복사된 이미지 레이어들의 위로 read-write 인 "컨테이너 레이어"가 생성된다 >> 컨테이너는 수정 가능하다
			: 이 컨테이너 레이어는 해당 컨테이너가 삭제될 떄 함께 삭제된다.

	: 용어
	    : CONTAINER ID 
		: 하나의 이미지로 다수의 컨테이너를 생성할 수 있으므로, 이의 식별을 위해 로컬에서 각 컨테이너가 ID를 가질 필요가 있다.

	    : CONTAINER NAME
		: 컨테이너 생성당시 --name 옵션으로 이름을 설정하지 않은경우, 도커 엔진이 임의로 형용사와 명사를 조합해 만든다. 이또한 "고유하다"


	: 도커 컨테이너의 상태 
		CREATED : 막 생성된 상태	
		RUNNING : 실행중인상태
		    : attatched / detached mode	
			: attached mode. >> 해당 컨테이너의 터미널 세션에 연결된 상태. 즉 해당 컨테이너에 내부 접속하여, 사용자의 기존 입력(?)이 차단되고 , 실행중인 컨테이너의 출력(로그)이 나오는 상태.
				: 터미널과 프로세스가 부모-자식으로 연결되므로, 터미널이 끊어지면 컨테이너까지 종료된다. 좀 위험하기 때문에 테스트 할 때만 이용해야된다.
				: 컨테이너의 실행 내용이 면전에 나오는거라 foreground mode 라고도 한다.
				: docker run VS docker attach 
					: docker run 실행시 기본 attached mode이다 (옵션으로 -d 옵션을 주면 detached mode로 실행시킬 수 있다)
					: 둘 다 attach mode 인건 맞는데, 그래도 약간 다르다.
						: docker run 은 현재 터미널 세션을 새로 생성한 컨테이너에게 할당 한 후, 그걸 사용한다는 개념이다. 그러니까 터미널 세션 할당과 연결을 둘 다 하는거다.
						: docker attach 는 어딘가에서 돌아가고 있던 터미널 세션을 현재 터미널 세션에 연결하여 사용하겠단 말이다. 그러니까 터미널 세션 연결만 하는거다.
				: 컨테이너를 start 시킨 상태에서 해당 컨테이너 내부에 접속하고 싶은 경우 attach 명령어를 사용하여 내부 접속 할 수 있고, 나오고 싶으면 exit 하면 된다.
		

			: detached mode>>  해당 컨테이너의 터미널 세션에 연결되있지 않은 상태. 즉, 사용자의 터미널 입력이 차단되지 않고, 실행중인 컨테이너의 로그가 따로 나오진 않는 상태
				: 터미널에 관계없이 지속적으로 실행 가능하다 .서비스형태로 실행할 때 attached mode 보단 많이 사용한다.
				: attached mode 와는 다르게 딱히 터미널 세션 연결, 할당 그런 개념이 사용되지 않는다.
				: 기본적으로 detached mode 에선 컨테이너의 로그가 나오지 않는데. 별도의 명령어로 지금까지 출력된 로그를 확인 하거나 , 앞으로의 로그를 계속 출력되게 할 수 있다
					: docker log [컨테이너id] >> 과거 로그내역 출력
						: 옵션으로 -f 를 주면 앞으로 로그내역 출력하게 할 수 있다.
				: 컨테이너의 실행 내용이 대놓곤 안나오는거라 background mode 라고도 한다.
				: docker start 실행시 기본 detached 상태이다

			: https://velog.io/@arnold_99/Docker-Attach-and-Detach
			: https://velog.io/@dong5854/%EB%8F%84%EC%BB%A4%EC%9D%98-attach-mode%EC%99%80-detach-mode

		RESTARTING : 재시작 "중"인 상태
		PAUSED : 중지 상태  
		EXITED : 종료 상태
			: EXITED( 0 ) >> 정상 종료됨
		DEAD : 컨테이너가 더이상 실행불가한 상태. 제거만 가능한 상태.
		: https://ttasjwi.tistory.com/100




	: 도커 컨테이너를 실행하는 과정
		: 컨테이너를 실행시키고, 컨테이너 내부의 프로세스가 모두 종료되면 .해당 컨테이너 역시 종료된다.

	: 특 
		1. 자체적으로 파일 시스템을 가진다
		    : 그러니까 host 나 다른 컨테이너에 설치되있는 패키지라 해서, 해당 컨테이너에서 쓸 수 있는게 아니란 말이다.
			ex )  터미널로 다른 컨테이너에 접속했을 때 , VM 에 net-tools 를 install 한 상태라고 해도, 해당 컨테이너 자체에 net-tools 를 install 한 적이 없다면 ifconfig 해도 COMMAND NOT FOUND 만 나온다.
			    : 그럼에도 불구하고 어떻게 가벼울 수가 있는 걸까? : 컨테이너는 VM 과는 다르게 자체적으로 운영체제를 가지진 않고, host os 를 활용하기 때문.


		2. 각 컨테이너는 독립적으로 실행된다


	: 도커 컨테이너에게 실행/중지/재실행/삭제 등의 명령을 내릴 수 있다
		
	  


도커의 구성요소 
    : 도커 클라이언트 <--> 도커 호스트 <--> 도커 레지스트리
	(1) 도커 클라이언트 Docker Client : 도커에 명령을 내릴 수 있는 CLI 도구.
		: 생각해보면 네이밍이 그럴싸한게, 요청하는 쪽이니까. 

	(2) 도커 호스트 Docker host : 도커가 설치된 (물리적인/가상의)서버.
		: 역시 역시 네이밍이 그럴싸한게, 요청에 따라 무언가 작업을 진행시키고 response 하는 쪽이니까.
		: 도커 데몬 Docker Daemon >> 도커와 관련된 리소스를 관리하는 백그라운드 프로세스

	(3) 도커 레지스트리 Docker Registry : 도커 이미지를 사용자들끼리 공유할 수 있는 플랫폼.
		: 레지스트리 종류 
			1. 공개 public : 벤더에서 구축한 레지스트리  
				: Docker 의 공식 레지스트리인 Docker hub 가 가장 유명하다
					: Docker Hub >> 다운 원하는 이미지를 검색 후 클릭하면, 해당 이미지에 대한 상세 정보와 다운로드 받을 수 있는 명령어를 확인 가능 

			2. 개인 private : 개인이 (팀원과의 공유등을 목적으로) 직접 구축한 레지스트리.





pull
    : 일반적인 pull >> 원격의 데이터를 로컬에 반영한다.
    : 깃허브에서의 pull
	(1) pull request >> 일반적이지 않은 pull. 특정 변경사항을 해당 원격 저장소에 반영해달라고(merge) 요청하는 것. 
		: 좀 헷갈리게 작명되었는데, 변경 내용을 끌고 온다는 맥락에서 pull 이란 용어를 쓴다고 한다.
	(2) git pull >> 일반적인 pull . 원격 저장소의 내용을 로컬 저장소에 반영하는 것.

***: docker 에서의 pull >>일반적인 pull. 원격의 데이터를 로컬에 다운 받는다.




애뮬레이션 Emulation : 특정 대상을 흉내내는데, 하드웨적인 동작까지 따라하는것
	: simulation VS Emulation >> 둘 다 무언가를 흉내내는 것.
		simulation : 소프트웨어 수준까지만 따라함
		emulation : 하드웨어 수준까지 따라함



가상터미널 TTY TeleTYpe : 사용자의 입력을 받아들이고, 출력을 화면에 표시하는 인터페이스 
	: tele + type . 원격에서 타이핑한다.
	: 한국어로 "가상" 인 이유는, 이전엔 터미널이 원래 물리적인 기기였는데 지금은 소프트웨어적으로 구현된 터미널을 사용하기 때문.
		: 가상머신의 터미널 뿐 아니라 그냥 내 컴터의 터미널도 "가상" 터미널인 것.

	: ＠에게 TTY 를 할당한다 == 현재 가상터미널에서 ＠와 상호작용가능하게 하겠다. 즉, 입력을 전달하고 출력을 보여주겠다.



터미널 세션 : 사용자가 특정 대상과 상호작용할 수 있는 텍스트 기반의 인터페이스. 명령어를 입력하고, 그 결과를 텍스트 형태로 출력받는 환경
   : 터미널 세션을 할당  VS 터미널 세션에 연결 >> 일단 둘다 접속한다는 개념이다.
	: 특정대상에게 터미널 세션을 할당 == "새로운" 터미널 세션을 시작하여 특정 대상(사용자, 프로세스, 컨테이너 등)이 해당 터미널 세션을 사용할 수 있게 하는 것을 의미

	: 특정대상의 터미널 세션에 연결 == "이미 실행 중인" 터미널 세션에 다시 연결하여 해당 세션에서 진행 중인 작업에 접근하고 상호작용하는 것을 의미 
		: docker run -it >>  터미널 세션 할당 && 터미널 세션 연결 : 새로운 생성된 컨테이너가 현재 터미널 환경을 사용할 수 있게 하고, 그 터미널 환경을 사용하겠다. 
		: docker attach >> 터미널 세션 연결 : 해당 컨테이너에 대해 이미 존재하던 터미널에 접속해   작업하겠다. 




셸 shell : 운영 체제와 상호작용 할 수 있게하는(=사용자의 명령어를 운영체제가 알아먹게 통역 및 실행) 프로그램. 
	: CLI , GUI 의 형태로 제공됨.
	: 쉘 스크립트 >> 쉘에서 사용할 수  있는 명령어로 쓰여진 batch 파일.
		: 쉘 스크립트는 맨 윗줄에 #!/bin/bash || #!/bin/sh 와 같이 해당 파일을 어떤 쉘로 해석할 수 있는지 지정해둔다.

	:  Linux에서 사용하는 Shell의 종류 >> bash , zsh , sh 등이 있다
		: Bourne Shell 쉘 
			: 경로 >>  /bin/sh 
		:  Bourne-Again Shell 쉘 
			: 경로 >> /bin/bash 

셸 세션 : 셸을 실행시킨 것. 셸과 셸 세션은 프로그램과 프로세스 느낌
	

docker 기초 명령어
    : 기본명령어 >> docker : docker 패키지를 사용하겠단 기본명령어

    : 하위 명령어
	: image >> 이미지에 대한 작업을 하겠다 
	    : pull >>   원격으로부터 특정이미지를 로컬에 다운로드 받겠다
		: 인수 ) "이미지명:태그명"
			: docker hub 가면 명령어 코드 다 써있고 걍 그거 복붙하면 된다.
			: 태그명은 버전이라고 봄 된다.
			: 태그명을 명시하지 않을 시 디폴트로 "latest" 가 적용된다.
				: 주의 >> 실제로 "latest" 라는 태그가 따로 있다. 버전 중 가장 최신 버전을 매치 시켜주겠다는 말이 아니다.

		: 출력되는 내용 ) 
			(1) "Using default tag: latest" 
				: 태그명을 명시하지않으면 이 문구가 나온다. (명시하면 안나옴)

			(2) "latest : pulling from library/이미지명" 
				: 해당 이미지를 원격저장소의 library/이미지명 에서 pull 을 받겠다. 

			(3) "이미지레이어다이제스트 : pull complete"
				: 해당 이미지 "레이어"가 성공적으로 다운로드 되었다. 
 					: 이미지레이어 >> 도커 이미지의 "특정" 레이어. 도커 이미지의 일부.
				: 이미지 레이어가 다운로드 될 떄마다 출력된다.
				: docker hub 에 나오는 해당 이미지의 수보다 더 적게 이 문구가 출력될 수도 있는데 , 이는 정상적인거다. 이미 존재하는 레이어일 경우 또 다운받지 않고 재사용하게 되어있기 떄문이다.

 
			(4) "Digest: 이미지다이제스트"
				: 이미지다이제스트 >> sha256기반으로 구해진 해당 도커 이미지 "자체"의 고유식별자
				:다이제스트 값으로도 해당 이미지를 똑같이 다운받을 수 있다 >> "docker image pull 이미지명@sha256:이미지다이제스트값"

			(5) "Status : Downloaded newer image for 이미지명: 태그명"
				: "이미지명: 태그명" 의 다운로드가 성공적으로 완료되었다

			(6) "docker.io/library/이미지명:태그명"
				: 다운로드 완료된 이미지의 URL


	    : push >> 레지스트리로 이미지를 업로드한다


	    : rm >> 특정 이미지를 삭제한다.
		: 인수로 이미지 ID  줘야된다


	    : ls >> 로컬에 다운로드된 이미지 목록을 확인하겠다
		: 출력되는 내용 ) 	
			1. REPOSITORY
			2. TAG
			3. IMAGE ID << pull 할 때와는 다르게 IMAGE DIGEST 가 나오는게 아님 주의
			4. CREATED
			5. SIZE


	    : tag >> 이미지 태그를 생성

	    : build >> Dockerfile 로 부터 이미지를 build 한다

	    : import >> 이미지 생성을 위해 tarball 콘텐츠를 불러온다.
	    : load >> tarball 로 묶인 이미지를 로드
	    : save >> 이미지를 tarball로 저장





	: container >> 컨테이너에 대한 작업을 하겠다 
	    : tip
		: run VS start VS create		
			: create >> 특정이미지로 컨테이너를 새로 생성하고, 따로 실행시키진 않는다
			: start >> 종료된(=생성된적있는) 컨테이너를 시작한다. 
			: run == start + create >> 특정이미지로 컨테이너를 새로 생성하고, 실행시킨다.
		: https://yooloo.tistory.com/40

	    : run >> 특정이미지의 컨테이너를 "새로" 생성 및 실행하겠다
		: 인수 ) 실행하고자 하는 이미지명
		******: 주의 >> 태그까지 명시해야된다. 안그럼 내 의지와 상관 없이 "latest" 가 적용된다.

		: 사실 run 은 container 이란 명령어 없이 바로 "docker run" 만 써도 되긴 하는데, container 라는 하위명령어를 명시하는게 권장된다.
		: 기본적으로 attached mode 로 실행된다. 즉, 현재 터미널 세션을 해당 container 에게 할당한다. foreground 에서 실행된다.

		: 옵션
			(1) 안줌 : 단순 실행시킴
				: 출력결과 ) 딱히 아웃풋이 뭔가 없다 

			(2) -i : interactive. 표준입력(STDIN) 을 열어두어, 사용자로부터 입력을 받을 수 있게 한다.
			(3) -t : tty. 가상터미널을 할당한다. 입력되는 명령어를 실행시킨다. 
				: 주의 >> -t 를 쓰면 입력되는 명령어를 실행시킬 수 있지만, 표준입력까지 알아서 제공해주지 않는다. 따라서 사용자로부터 입력 받은 명령어를 수행시키고 싶으면 -i 옵션과 함께 써야된다.
			(4) -d: detached mode 로 실행시킨다.


		 : 유용한 옵션 세트
			(1) -it : 컨테이너 내부에 들어가고 싶을 때 사용.
				: 의미 >> 현재 가상 터미널에서, 키보드 입력을 컨테이너에게 전달하고 그 결과를 출력하여 해당 컨테이너와 상호작용하겠다.
				: 결과 >>
					1. 사용자 이름과 호스트 이름이 바뀐다.
						사용자는 >> root 로
						호스트이름은 >> 컨테이너 ID

				: 컨테이너 밖으로 나오는 법 == 해당 컨테이너 종료하는 것
					sol1 ) 걍 exit << 개추
					sol2 ) docker container stop 컨테이너ID

	    : pause >> 실행중인 컨테이너를 중지시키겠다.
	    : unpause >> 일시정지된 컨테이너를 재실행시키겠다.


	    : stop >> 실행중인 컨테이너를 종료하겠다. (== 종료 )
 		: 인수로 컨테이너Id || 컨테이너 name  를 줘야된다

	    : kill >> 실행중인 컨테이너를 "즉시" 종료하겠다. (== 강제종료 )
		: 인수로  컨테이너Id || 컨테이너 name  줘야된다
		: stop 보다는 효율성이 떨어진다.

	    : restart >> 실행중인 컨테이너를 종료했다가 다시 실행시키겠다. (== 다시시작 )

	    : start >> 종료된 컨테이너(=이미 run 된적있는컨테이너)에 다시 접속하겠다. 
		: 기본적으로 detached mode 로 실행된다. 즉, background 에서 컨테이너가 실행된다

	    : attach >> 현재 "실행중인" 컨테이너 대해 내부 접속(== 터미널 세션에 연결)하겠다. 
		: 그러니까 start 명령어가 선행된 이후에 사용가능한거다
		: 인수로 "컨테이너 Id || name"  줘야된다


	    : exec >> 현재 "실행중인" 컨테이너에 명령어를 실행함
		: 애는 attach 와는 다르게, 표준입출력 등까지 연결하진 않고 단순 내부에서 명령어를 실행하는 역할만 한다
		: 인수로  "컨테이너 Id || name" , "명령어"룰 줘야된다
			: 그러니까  docker container exec [컨테이너Id || 컨테이너name] [ command ] 
		: exec VS attach >> 둘다 (실행중인) 컨테이너에 명령어를 실행시킴. 
			: exec >> 컨테이너 외부에서 접근해 명령어를 실행시킨다. 
				: 대체적으로 내부에서 직접 실행시키는거랑 효과는 같다. 예외적으로 cd 명령어는 수행시키지 못한다.
				: 일회성으로 명령어를 실행시키는거다. 해당 컨테이너를 재시작한다고 해서 해당 명령어가 자동적으로 실행되는게 아니다.
				: 디버깅 용도로 주로 사용

			: attach >> 컨테이너 내부에 접속해 직접 명령어를 작동시킨다.

	    : rm >> 특정 컨테이너를 삭제한다.
		: 인수로 컨테이너Id || 컨테이너 name  줘야된다
			: 인수로 여러개의 컨테이너 Id || name 주면 한번에 삭제 가능하다.


	    : commit >> 해당 컨테이너를 이미지로 저장한다. 
		: 인수로 "수정이반영된컨테이너 Id || name", "새로운이미지명" 을 줘야된다
			: 그러니까  docker container commit [컨테이너Id || 컨테이너name] [ 새이미지명 ] 


	    : ls >> 현재 "실행중인" 도커 컨테이너 목록을 확인하겠다.
		: "docker ps" (Process Status) 로도 이와 동일한 기능을 수행할 수 있는데, 그건 좀 구식이고 요즘엔 ( 명령어를 일관적으로 하기 위해 ) 이렇게 쓴다. 
		: 출력결과 ) 	
			1. CONTAINER ID 
			2. IMAGE 
			3. COMMAND : 해당 컨테이너가 실행할떄, 함께 실행되게 설정된 주 프로세스(의 경로)
				: 개발자가 따로 만질 필요는 없음
				: 주 프로세스 >> docker container 가 시작될 떄 가장 먼저 실행되는 기본 프로세스로, 컨테이너의 시작/종료와 함께 시작/종료된다.

			4. CREATED : 컨테이너가 생성되고 난 뒤 흐른 시간
			4. STATUS  :
				: 3가지중 하나로 출력됨
					UP : 실행중인 상태
					PAUSED : 중지 상태  
					EXITED : 종료 상태
						: EXITED( 0 ) >> 정상 종료됨

			5. PORTS: 포트 포워딩, 호스트 포트와 컨테이너 포트의 연결 관계
			6. NAMES  : 컨테이너의 이름

		: 옵션
			(1) 안줌 : 실행 상태의 컨테이너만 출력됨
			(2) -a : all. 실행 상태, 정지 상태의 컨테이너를 모두 출력




도커의 작동 방식
	1. 도커 클라이언트에서 (이미지를 다운받는) 명령어를 입력 : docker image pull [이미지명:태그명]
	2. 도커 호스트의 데몬이 해당 명령어를 받고 해당 이미지가 존재하는지 확인
		case 1, 도커 호스트에 해당 이미지가 존재하지 않으면, "도커레지스트리"에서 해당 이미지를 다운로드 받음  
			ex ) hello-world 이미지가 다운로드되있지 않은 상황에서 "docker container run hello-world" 의 작동 과정
				1. docker container run hello-world 명령어 입력
					: docker >> docker 패키지를 사용하겠단 기본명령어
					: container >> 컨테이너 대한 작업 하겠다.
					: run >> 컨테이너를 실행하겠단 하위 명령어
					: hello-world >> 컨테이너 이름

				2. 출력됨
					(1) "unalbe to find image 'hello-world:latest' locally" 
						: 로컬에서 hello-world 를 찾을 수 없다. 해당 이미지가 다운로드 안되어있다.
					(2) "latest : pulling from library/hello-world" 
						: 해당 이미지가 다운로드 되어있지 않으니 library/hello-world 에서 pull 을 받겠다. 
					(3) "이미지레이어다이제스트 : pull complete"
					(4) "Digest: 이미지다이제스트"
					(5) "Status : Downloaded newer image for hello-world: latest"
						: hello-world: latest 의 다운로드가 완료되었다


		case 2. 도커 호스트에 해당 이미지가 존재한다면
			ex ) hello-world 이미지가 다운로드되있는 상황에서 "docker container run hello-world" 의 작동 과정
				1. docker container run hello-world 명령어 입력
				2. (따로 뭔가 출력되진 않고) 로컬에 있는 이미지가 실행된다




