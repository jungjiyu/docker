도커 기초 지식
	- 도커의 구성 요소, 작동방식
	- 컨테이터로 실행하는데 필요한 내용 학습
	- 관련 명령어
	- 도커 네트워크, 스토리지

------------------------------------------------------------------------------------------

architecture 
	: cpu 의 종류를 의미.
	: 대표적인 architecture
		: intel 기반 >> 현존하는 "pc 프로그램" 대부분이 이 아키텍처를 지원
			1.  x86 >> 32 bit 기반 cpu 
			2.  amd64(= x86_64) >> 64 bit 기반 cou
				: 사실 완전 intel 기반은 아니고, 하위 호환 개념. 쩄뜬 잘 작동한다. 

		: arm 기반 >> "모바일 앱"이 이 아키텍처를 지원
		    : pc 프로그램의 경우 linux 와 mac 은 arm 을 지원하지만, windows 는 지원을 안함
			1. arm >> 32 bit 기반 cpu
			2. arm64 >> 64 bit 기반 cpu

	: 애플리케이션, 라이브러리가 실행될 서버의 아키텍처를 알아야하는 이유 >> 애플리케이션은 결국 "사전 컴파일"된 바이너리( 라이브러리도 대부분 사전 컴파일되어 제공된다 ). 이때 이 컴파일을 어떤 CPU 로 했느냐 따라 결과물이 달라진다.  intel 기반 cpu 로 빌드한 애플리케이션을 그냥 arm 기반 cpu 로 가져오면 실행이 안된다. 
	: 도커 이미지 같은 경우도,  pull 받을 때 그 머신의 CPU에 따라 맞는 아키텍처를 받아야된다.
		: docker hub 가보면 x86-64 , arm64 등 따로 구분되어있다  
	: https://velog.io/@480/%EC%9D%B4%EC%A0%9C%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%8F%84-CPU-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%A5%BC-%EA%B5%AC%EB%B6%84%ED%95%B4%EC%95%BC-%ED%95%A9%EB%8B%88%EB%8B%A4




하위 명령어
	: 리눅스에서 기본 명령어 다음에 하위 명령어가 올 수 있다. 
	: 각 하위 명령어는 일반 명령어와 마찬가지로 옵션 과 인수를 가질 수 있다.
		: ex ) docker run hello-world , docker pull ubuntu
	: 하위 명령어와 인수를 구별하는 tip
		: 하위 명령어는 보통 특정 작업을 지칭하는 동사형이다.
			: 사실 걍 보면 아 이새끼는 인수가 아니구나 라는 느낌이 온다
		: 인수는 보통 특정 자료 같은 명사형이다 .



(일반적인) 이미지 : 물리적인 광매체(cd, dvd 등)를 압축한 파일. 
	: 광매체에 이미지라는 표현을 많이 쓰다보니 이미지 파일이라는 이름이 붙여진것
	: 다운로드/저장/백업 용으로 쓰인다.
	: 굳이 광매체를 압축해서 이미지로 만든 건 일일이 CD 같은거 들고다니기 귀찮으니까.
	: https://blog.naver.com/taeho930/220488967313 



도커 이미지 image : 컨테이너 형태로 소프트웨어를 배포하기 위해, 필요한 모든 파일을 포함하는 패키지.
	: 모든 도커 컨테이너는 도커 이미지를 기반으로 생성된다.
	: debain OS 에서 apt install 을 하면 기본적으로 apt 레파지토리에서 패키지를 내려받듯이 도커는 기본적으로 docker hub 에서 이미지를 내려받는다.

	: 구조 >> 효율적 사용을 위해 레이어 구조로 이뤄짐.
		: 도커 이미지는 컨테이너를 실행하기 위한 모든 파일을 가지고 있기에 용량이 크다.( 수백 MB )
			: (이미지를 수정없이 계속 사용한다면 별 문제 없겠지만) 이미지에서 파일 하나를 수정한다고 했을 때, 기존이미지 와 수정한 파일을 모두 받아야된다면 매우 비효율적일 것. >> 이러한 문제 해결을 위해 도커 이미지는 레이어 구조로 이뤄짐

		: 여러개의 read only (읽기 전용. 수정 불가)레이어 로 구성되고, 파일이 추가되거나 수정되면 새로운 레이어가 생성됨 >> base layer(기존 layer들)은 변경 필요 없이 새로운 layer 를 추가만 하면됨
			: read only 이기 때문에 파일을 추가할 때 뿐아니라, 수정할 때에도 새로운 layer 가 추가된다
			: 이미지는 read only 이기에 특정 시점의 도커 컨테이너의 상태를 담은 "스냅샷"이라고 볼 수 있다.
				 : 특정 시점의 상태를 사진 찍어둔 것처럼 그대로 저장해둔 것이니까. 
			: 이미지 자체는 읽기 전용이기에 실행이 불가하다.
			: 동일한 환경을 가진 컨테이너를 마음껏 생성 가능하게 해준다


		: 이미지를 pull 시키면 해당 이미지의 레이어 단위로 차곡차곡 pull 된다.

	: 특정이미지를 기반으로 컨테이너를 생성하면
		step1. 이미지가 이미지 레이어형태로 컨테이너가 실행될 떄 복사되고, 이 이미지 레이어들은 도커 이미지에서와 마찬가지로 read-only 이다 >> 이미지 베이스(복사된 이미지 레이어들)은 수정 불가이다.
		step2. 복사된 이미지 레이어들의 위로 read-write 인 "컨테이너 레이어"가 생성된다 >> 컨테이너는 수정 가능하다
			: 이 컨테이너 레이어는 해당 컨테이너가 삭제될 떄 함께 삭제된다.
	
			
	: 도커 레지스트리에 저장되어 관리된다.
	: 일종의 템플릿이라고 볼 수 있다.
	: 독립적이라 의존성 고려 필요 없음

	: TAG >> 도커 이미지의 특정 버전
	: MANIFEST >> 특정 버전의 도커 이미지의 특정 아키텍쳐 같은거
	: 고유식별자
 		: 이미지레이어 ID >> 특정 태그의 도커 이미지의 "특정"(=일부) 레이어(layer) ID
			: 특정 도커 이미지의 특정 레이어를 의미

		: . 이미지 다이제스트.  >>  특정 태그의 도커 이미지 "자체"의  ID
			: SHA256 해시 값을 사용하여 생성된 값으로, 해당 이미지가 도커레지스트리에 push 될 때 결정된다. (매번 pull 받을 때마다 새롭게 구해지는게 아니다)
			: docker hub 에서 확인 가능하다 <-- index digest 옆에 표기되어있다
			: 이게 "이미지 인덱스"이다.
			: when 사용
				: 이미지가 변경되지 않았음을 보장하는 데 사용
				: 각 이미지를 식별하기 위해 사용


	: 상세 구조
		: https://ga0lee.tistory.com/entry/DevOps-Docker-%EA%B8%B0%EC%B4%88-%EB%AA%85%EB%A0%B9%EC%96%B41-Docker-Image-%EB%8B%A4%EC%9A%B4%EB%A1%9C
		1. 이미지 인덱스 image index >> 특정 도커이미지 자체. manifest"들" 
			: 이미지 pull 할 때 출력되는 Digest == 이미지 인덱스 
			: 이미지 인덱스 == 매니페스트 리스트. 

		2. 이미지 매니페스트 image manifest >> 특정 도커이미지들의 그룹 . "config" + "layer들"
			: 다양한 환경에서 해당 이미지를 활용할 수 있도록. "특정 config" 와 "레이어들"을 제공. 
			: config >> 해당 이미지가 어떻게 만들어졌고, 어떻게 실행 가능한지 등에 대한 메타데이터가 들어있다
			: 이미지 "매니페스트" 라고 부르는건, 여러 레이어들을 포함하는 개념이라. 레이어들의 목록이라 그런 것 같다.

		3. 레이어 layer >> 특정 도커이미지의 레이어. tar 형식으로 압축된 각 레이어에 대한 파일
			: 이미지를 pull 할 때 출력되는 각 이미지 레이어 == 이미지 레이어 
			

	: https://seosh817.tistory.com/377



(통상적인) 데몬 Daemon >> 백그라운드 프로세스. 밑에서 돌아가는.
도커 데몬 >> 도커 관련 작업을 하는 백그라운드 프로세스


digest : 해시함수 산출값.

매니페스트 manifest : 어떤 것에 대한 명단. 목록.
	: 영단어 뜻 자체로는 "화물 목록" 이다.
	: https://bsnippet.tistory.com/7



도커 컨테이너 container : 도커 이미지를 실행할 수 있는 인스턴스 instance .
	: 도커 이미지로부터 생성된다. 
	: 도커 컨테이너에게 실행/중지/재실행/삭제 등의 명령을 내릴 수 있다
	: 특 
		1. 자체적으로 파일 시스템을 가진다
		2. 각 컨테이너는 독립적으로 실행된다

 	   >> 각 컨테이너는 자체적으로 파일 시스템을 포함한다
		    : 그럼에도 불구하고 어떻게 가벼울 수가 있는 걸까? : 컨테이너는 VM 과는 다르게 자체적으로 운영체제를 가지진 않고, host os 를 활용하기 때문.



	  


도커의 구성요소 
    : 도커 클라이언트 <--> 도커 호스트 <--> 도커 레지스트리
	(1) 도커 클라이언트 Docker Client : 도커에 명령을 내릴 수 있는 CLI 도구.
		: 생각해보면 네이밍이 그럴싸한게, 요청하는 쪽이니까. 

	(2) 도커 호스트 Docker host : 도커가 설치된 (물리적인/가상의)서버.
		: 역시 역시 네이밍이 그럴싸한게, 요청에 따라 무언가 작업을 진행시키고 response 하는 쪽이니까.
		: 도커 데몬 Docker Daemon >> 도커와 관련된 리소스를 관리하는 백그라운드 프로세스

	(3) 도커 레지스트리 Docker Registry : 도커 이미지를 사용자들끼리 공유할 수 있는 플랫폼.
		: 레지스트리 종류 
			1. 공개 public : 벤더에서 구축한 레지스트리  
				: Docker 의 공식 레지스트리인 Docker hub 가 가장 유명하다
					: Docker Hub >> 다운 원하는 이미지를 검색 후 클릭하면, 해당 이미지에 대한 상세 정보와 다운로드 받을 수 있는 명령어를 확인 가능 

			2. 개인 private : 개인이 (팀원과의 공유등을 목적으로) 직접 구축한 레지스트리.


도커의 작동 방식
	1. 도커 클라이언트에서 (이미지를 다운받는) 명령어를 입력 : docker image pull [이미지명:태그명]
	2. 도커 호스트의 데몬이 해당 명령어를 받고 해당 이미지가 존재하는지 확인
		case 1, 도커 호스트에 해당 이미지가 존재하지 않으면, "도커레지스트리"에서 해당 이미지를 다운로드 받음  
		case 2. 도커 호스트에 해당 이미지가 존재한다면 ..? 


pull
    : 일반적인 pull >> 원격의 데이터를 로컬에 반영한다.
    : 깃허브에서의 pull
	(1) pull request >> 일반적이지 않은 pull. 특정 변경사항을 해당 원격 저장소에 반영해달라고(merge) 요청하는 것. 
		: 좀 헷갈리게 작명되었는데, 변경 내용을 끌고 온다는 맥락에서 pull 이란 용어를 쓴다고 한다.
	(2) git pull >> 일반적인 pull . 원격 저장소의 내용을 로컬 저장소에 반영하는 것.

    : docker 에서의 pull >>일반적인 pull. 원격의 데이터를 로컬에 다운 받는다.


hello-world 이미지가 다운로드되있지 않은 상황에서 "docker run hello-world" 의 작동 과정
	1. docker run hello-world 명령어 입력
		: docker >> docker 패키지를 사용하겠단 기본명령어
		: run >> 컨테이너를 실행하겠단 하위 명령어
		: hello-world >> 컨테이너 이름

	2. 출력됨
		(1) "unalbe to find image 'hello-world:latest' locally" 
			: 로컬에서 hello-world 를 찾을 수 없다. 해당 이미지가 다운로드 안되어있다.
		(2) "latest : pulling from library/hello-world" 
			: 해당 이미지가 다운로드 되어있지 않으니 library/hello-world 에서 pull 을 받겠다. 
		(3) "이미지레이어ID : pull complete"
		(4) "Digest: 이미지다이제스트"
		(5) "Status : Downloaded newer image for hello-world: latest"
			: hello-world: latest 의 다운로드가 완료되었다




docker 기초 명령어
    : 기본명령어 >> docker : docker 패키지를 사용하겠단 기본명령어

    : 하위 명령어
	: run >> 특정컨테이너를 실행하겠다
		: 인수 ) 실행하고자 하는 컨테이너 명

	: image pull >> 원격으로부터 특정이미지를 로컬에 다운로드 받겠다
		: 인수 ) "이미지명:태그명"
			: docker hub 가면 명령어 코드 다 써있고 걍 그거 복붙하면 된다.
			: 태그명은 버전이라고 봄 된다.
			: 태그명을 명시하지 않을 시 디폴트로 "latest" 가적용된다. 즉 최신버전이 적용된다
		: 출력되는 내용 ) 
			(1) "Using default tag: latest" 
				: 태그명을 명시하지않을 경우 디폴트로 latest 태그를 적용시키겠다는 문구가 나온다
			(2) "latest : pulling from library/이미지명" 
				: 해당 이미지를 원격저장소의 library/이미지명 에서 pull 을 받겠다. 

			(3) "이미지레이어ID : pull complete"
				: 해당 이미지 "레이어"가 성공적으로 다운로드 되었다. 
 					: 이미지레이어 >> 도커 이미지의 "특정" 레이어. 도커 이미지의 일부.
				: 해당 이미지가 가지는 레이어의 수 만큼 출력된다. 

			(4) "Digest: 이미지다이제스트"
				: 이미지다이제스트 >> sha256기반으로 구해진 해당 도커 이미지 "자체"의 고유식별자
				:다이제스트 값으로도 해당 이미지를 똑같이 다운받을 수 있다 >> "docker image pull 이미지명@sha256:이미지다이제스트값"

			(5) "Status : Downloaded newer image for 이미지명: 태그명"
				: "이미지명: 태그명" 의 다운로드가 성공적으로 완료되었다

			(6) "docker.io/library/이미지명:태그명"
				: 다운로드 완료된 이미지의 URL




????????????
도커 이미지:  런타임 환경을 위한 일종의 템플릿. 애플리케이션을 실행하는데 필요한 환경에 대한 파일. 
	: 애플리케이션을 포장 및 전송하기 위한 용도.
	: 읽기 전용이다 (수정 불가)
		; 읽기만 할 수 있다는 점에서 스냅샷이라고도 불린다.
	******: 특정 시점의 애플리케이션과 가상환경을 나타낸다. 일관적이다
			: 개발자가 균일한 조건에서 애플리케이션을 테스트할 수 있게 해준다
 	: 템플릿일 뿐이라, 시작하거나 실행할 순 없다.
	: 하나의 "이미지 베이스" 에서 "도커 이미지"를 무제한으로 생성할 수 있다.
		: 도커 이미지는 여러 개의 레이어로 구성될 수 있다
		: 각도커 이미지는 이전 레이어에서 비롯된다.
	: 이미지 계층은 
	: https://sunrise-min.tistory.com/entry/Docker-Container%EC%99%80-Image%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80

컨테이너 : 실행중인 이미지.
	: 컨테이너 생성 시 "이미지 레이어" 위에 "쓰기 가능한 레이어"가  추가된다.
		: 즉 , 컨테이너는 이미지와 다르게 수정이 가능하다 
		: 
	: 컨테이너 실행시, 기본적으로 컨테이너 내부에 도커이미지의 읽기-쓰기 복사본을 만든다.

????????????????
