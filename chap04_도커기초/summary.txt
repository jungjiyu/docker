도커 기초 지식
	- 도커의 구성 요소, 작동방식
	- 컨테이터로 실행하는데 필요한 내용 학습
	- 관련 명령어
	- 도커 네트워크, 스토리지

------------------------------------------------------------------------------------------


alt + F2 ,F3 ...  누르면 새로운 터미널 열 수 있다 !!
	: 인터넷의 다른건 해봤을 때 안먹혔다
	: 특정 터미널로 이동하고 싶을 땐 "alt + 해당Fn" 누름 된다 


architecture 
	: cpu 의 종류를 의미.
	: 대표적인 architecture
		: intel 기반 >> 현존하는 "pc 프로그램" 대부분이 이 아키텍처를 지원
			1.  x86 >> 32 bit 기반 cpu 
			2.  amd64(= x86_64) >> 64 bit 기반 cou
				: 사실 완전 intel 기반은 아니고, 하위 호환 개념. 쩄뜬 잘 작동한다. 

		: arm 기반 >> "모바일 앱"이 이 아키텍처를 지원
		    : pc 프로그램의 경우 linux 와 mac 은 arm 을 지원하지만, windows 는 지원을 안함
			1. arm >> 32 bit 기반 cpu
			2. arm64 >> 64 bit 기반 cpu

	: 애플리케이션, 라이브러리가 실행될 서버의 아키텍처를 알아야하는 이유 >> 애플리케이션은 결국 "사전 컴파일"된 바이너리( 라이브러리도 대부분 사전 컴파일되어 제공된다 ). 이때 이 컴파일을 어떤 CPU 로 했느냐 따라 결과물이 달라진다.  intel 기반 cpu 로 빌드한 애플리케이션을 그냥 arm 기반 cpu 로 가져오면 실행이 안된다. 
	: 도커 이미지 같은 경우도,  pull 받을 때 그 머신의 CPU에 따라 맞는 아키텍처를 받아야된다.
		: docker hub 가보면 x86-64 , arm64 등 따로 구분되어있다  
	: https://velog.io/@480/%EC%9D%B4%EC%A0%9C%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%8F%84-CPU-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%A5%BC-%EA%B5%AC%EB%B6%84%ED%95%B4%EC%95%BC-%ED%95%A9%EB%8B%88%EB%8B%A4




하위 명령어
	: 리눅스에서 기본 명령어 다음에 하위 명령어가 올 수 있다. 
	: 각 하위 명령어는 일반 명령어와 마찬가지로 옵션 과 인수를 가질 수 있다.
		: ex ) docker run hello-world , docker pull ubuntu
	: 하위 명령어와 인수를 구별하는 tip
		: 하위 명령어는 보통 특정 작업을 지칭하는 동사형이다.
			: 사실 걍 보면 아 이새끼는 인수가 아니구나 라는 느낌이 온다
		: 인수는 보통 특정 자료 같은 명사형이다 .




digest : 해시함수 산출값.
	: DIGEST vs ID >> 모두 식별자 개념
		: digest 는 찐으로 고유한 느낌 >> docker 에서 digest 는 push 될 때 결정되고, pull 이 어디서 되건간에 항상 그 값을 유지한다.
		: id 는 환경적.지역적으로 고유한 느낌 >> docker 에서 id 는 pull 되는 환경에서 , 도커가 내부적으로 사용하는 식별자. (캐시등에서 활용하기 위해)


매니페스트 manifest : 어떤 것에 대한 명단. 목록.
	: 영단어 뜻 자체로는 "화물 목록" 이다.
	: https://bsnippet.tistory.com/7



(일반적인) 이미지 : 물리적인 광매체(cd, dvd 등)를 압축한 파일. 
	: 광매체에 이미지라는 표현을 많이 쓰다보니 이미지 파일이라는 이름이 붙여진것
	: 다운로드/저장/백업 용으로 쓰인다.
	: 굳이 광매체를 압축해서 이미지로 만든 건 일일이 CD 같은거 들고다니기 귀찮으니까.
	: https://blog.naver.com/taeho930/220488967313 



도커 이미지 image : 컨테이너 형태로 소프트웨어를 배포하기 위해, 필요한 모든 파일을 포함하는 패키지.
	: 모든 도커 컨테이너는 도커 이미지를 기반으로 생성된다.
	: debain OS 에서 apt install 을 하면 기본적으로 apt 레파지토리에서 패키지를 내려받듯이 도커는 기본적으로 docker hub 에서 이미지를 내려받는다.

	: 구조 >> 효율적 사용을 위해 레이어 구조로 이뤄짐.
		: 도커 이미지는 컨테이너를 실행하기 위한 모든 파일을 가지고 있기에 용량이 크다.( 수백 MB )
			: (이미지를 수정없이 계속 사용한다면 별 문제 없겠지만) 이미지에서 파일 하나를 수정한다고 했을 때, 기존이미지 와 수정한 파일을 모두 받아야된다면 매우 비효율적일 것. >> 이러한 문제 해결을 위해 도커 이미지는 레이어 구조로 이뤄짐

		: 여러개의 read only (읽기 전용. 수정 불가)레이어 로 구성되고, 파일이 추가되거나 수정되면 새로운 레이어가 생성됨 >> base layer(기존 layer들)은 변경 필요 없이 새로운 layer 를 추가만 하면됨
			: read only 이기 때문에 파일을 추가할 때 뿐아니라, 수정할 때에도 새로운 layer 가 추가된다
			: 이미지는 read only 이기에 특정 시점의 도커 컨테이너의 상태를 담은 "스냅샷"이라고 볼 수 있다.
				 : 특정 시점의 상태를 사진 찍어둔 것처럼 그대로 저장해둔 것이니까. 
			: 이미지 자체는 읽기 전용이기에 실행이 불가하다.
			: 동일한 환경을 가진 컨테이너를 마음껏 생성 가능하게 해준다


		: 이미지를 pull 시키면 해당 이미지의 레이어 단위로 차곡차곡 pull 된다.

	

	: 용어
	    : REPOSITORY >> 특정 도커 이미지 자체
		: ex) python , ubuntu
  	    : TAG , INDEX >> 특정 도커 이미지의 특정 버전
		: ex) python:3.9.19 에서 "3.9.19"
	    : MANIFEST >> 도커 이미지의 특정 아키텍쳐. 
		: ex) python:3.9.19 의 amd64 버전
		:"config" + "layer들". 다양한 환경에서 해당 이미지를 활용할 수 있도록. "특정 config" 와 "레이어들"을 제공. 
			: config >> 해당 이미지가 어떻게 만들어졌고, 어떻게 실행 가능한지 등에 대한 메타데이터가 들어있다
			: 이미지 "매니페스트" 라고 부르는건, 여러 레이어들을 포함하는 개념이라. 레이어들의 목록이라 그런 것 같다.


	    : DIGEST
		: INDEX DIGEST >>  "태그"에 대한 식별자
			: SHA256 해시 값을 사용하여 생성된 값으로, 해당 이미지가 도커레지스트리에 push 될 때 결정된다. (매번 pull 받을 때마다 새롭게 구해지는게 아니다)
			: when 사용
				: 이미지가 변경되지 않았음을 보장하는 데 사용
				: 각 이미지를 식별하기 위해 사용
			: docker hub 에서 확인 가능하다 <-- index digest 옆에 표기되어있다
			: docker image pull 할 때도 확인 가능하다 <-- 끝쪽 부분에 "Digest : ... " 으로 출력된다.			

 		: MANIFEST DIGEST >> "아키텍쳐"에 대한 식별자
			: 특정 태그의 도커 이미지의 특정 아키텍쳐를 의미
				: 그러니까 마냥 amd64과 같은 아키텍쳐에 대한 식별는 아니고, "python:3.9.11" 과 같은 특정 태그의 도커 이미지 중 아키텍쳐가 amd64 인것을 의미한다.
 
 		: LAYER DIGEST >> "레이어"에 대한 식별자
			: 특정 아키텍쳐의 특정 태그의 도커 이미지의 특정 레이어를 의미
			: docker image pull 할 때도 확인 가능하다 <-- 앞부분에 "  ... : Pull complete" 으로 출력된다.			
	
	    : ID
		: IMAGE ID >> 다운로드한 도커 이미지에, 로컬에서 부여한 ID값.

			
	: 도커 레지스트리에 저장되어 관리된다.
	: 일종의 템플릿이라고 볼 수 있다.
	: 독립적이라 의존성 고려 필요 없음
	: https://seosh817.tistory.com/377



(통상적인) 데몬 Daemon >> 백그라운드 프로세스. 밑에서 돌아가는.
도커 데몬 >> 도커 관련 작업을 하는 백그라운드 프로세스




도커 컨테이너 container : 도커 이미지를 실행할 수 있는 인스턴스 instance .
	: 도커 이미지로부터 생성된다. 
	: 특정이미지를 기반으로 컨테이너를 생성하는 과정
		step1. 컨테이너가 실행될 떄, 도커이미지가 이미지 레이어 형태로  복사된다. 이 이미지 레이어들은 도커 이미지에서와 마찬가지로 read-only 이다 >> 이미지 베이스(복사된 이미지 레이어들)은 수정 불가이다.
		step2. 복사된 이미지 레이어들의 위로 read-write 인 "컨테이너 레이어"가 생성된다 >> 컨테이너는 수정 가능하다
			: 이 컨테이너 레이어는 해당 컨테이너가 삭제될 떄 함께 삭제된다.

	: 용어
	    : CONTAINER ID 
		: 하나의 이미지로 다수의 컨테이너를 생성할 수 있으므로, 이의 식별을 위해 로컬에서 각 컨테이너가 ID를 가질 필요가 있다.

	: 도커 컨테이너의 상태 
		EXITED : 종료된 상태
			: EXITED( 0 ) >> 정상 종료됨

	: 도커 컨테이너를 실행하는 과정
		: 컨테이너를 실행시키고, 컨테이너 내부의 프로세스가 모두 종료되면 .해당 컨테이너 역시 종료된다.

	: 특 
		1. 자체적으로 파일 시스템을 가진다
		2. 각 컨테이너는 독립적으로 실행된다

 	   >> 각 컨테이너는 자체적으로 파일 시스템을 포함한다
		    : 그럼에도 불구하고 어떻게 가벼울 수가 있는 걸까? : 컨테이너는 VM 과는 다르게 자체적으로 운영체제를 가지진 않고, host os 를 활용하기 때문.

	: 도커 컨테이너에게 실행/중지/재실행/삭제 등의 명령을 내릴 수 있다
		
	  


도커의 구성요소 
    : 도커 클라이언트 <--> 도커 호스트 <--> 도커 레지스트리
	(1) 도커 클라이언트 Docker Client : 도커에 명령을 내릴 수 있는 CLI 도구.
		: 생각해보면 네이밍이 그럴싸한게, 요청하는 쪽이니까. 

	(2) 도커 호스트 Docker host : 도커가 설치된 (물리적인/가상의)서버.
		: 역시 역시 네이밍이 그럴싸한게, 요청에 따라 무언가 작업을 진행시키고 response 하는 쪽이니까.
		: 도커 데몬 Docker Daemon >> 도커와 관련된 리소스를 관리하는 백그라운드 프로세스

	(3) 도커 레지스트리 Docker Registry : 도커 이미지를 사용자들끼리 공유할 수 있는 플랫폼.
		: 레지스트리 종류 
			1. 공개 public : 벤더에서 구축한 레지스트리  
				: Docker 의 공식 레지스트리인 Docker hub 가 가장 유명하다
					: Docker Hub >> 다운 원하는 이미지를 검색 후 클릭하면, 해당 이미지에 대한 상세 정보와 다운로드 받을 수 있는 명령어를 확인 가능 

			2. 개인 private : 개인이 (팀원과의 공유등을 목적으로) 직접 구축한 레지스트리.





pull
    : 일반적인 pull >> 원격의 데이터를 로컬에 반영한다.
    : 깃허브에서의 pull
	(1) pull request >> 일반적이지 않은 pull. 특정 변경사항을 해당 원격 저장소에 반영해달라고(merge) 요청하는 것. 
		: 좀 헷갈리게 작명되었는데, 변경 내용을 끌고 온다는 맥락에서 pull 이란 용어를 쓴다고 한다.
	(2) git pull >> 일반적인 pull . 원격 저장소의 내용을 로컬 저장소에 반영하는 것.

***: docker 에서의 pull >>일반적인 pull. 원격의 데이터를 로컬에 다운 받는다.




애뮬레이션 Emulation : 특정 대상을 흉내내는데, 하드웨적인 동작까지 따라하는것
	: simulation VS Emulation >> 둘 다 무언가를 흉내내는 것.
		simulation : 소프트웨어 수준까지만 따라함
		emulation : 하드웨어 수준까지 따라함



가상터미널 TTY TeleTYpe : 사용자의 입력을 받아들이고, 출력을 화면에 표시하는 인터페이스 
	: tele + type . 원격에서 타이핑한다.
	: 한국어로 "가상" 인 이유는, 이전엔 터미널이 원래 물리적인 기기였는데 지금은 소프트웨어적으로 구현된 터미널을 사용하기 때문.
		: 가상머신의 터미널 뿐 아니라 그냥 내 컴터의 터미널도 "가상" 터미널인 것.

	: 특정 컨테이너에게 TTY 를 할당한다 == 해당 프로그램(?)에서 실행되는 프로그램이 해당 터미널에서 동작하게 하겠다.

	

docker 기초 명령어
    : 기본명령어 >> docker : docker 패키지를 사용하겠단 기본명령어

    : 하위 명령어
	: image >> 이미지에 대한 작업을 하겠다 
	    : pull >>   원격으로부터 특정이미지를 로컬에 다운로드 받겠다
		: 인수 ) "이미지명:태그명"
			: docker hub 가면 명령어 코드 다 써있고 걍 그거 복붙하면 된다.
			: 태그명은 버전이라고 봄 된다.
			: 태그명을 명시하지 않을 시 디폴트로 "latest" 가 적용된다.
				: 주의 >> 실제로 "latest" 라는 태그가 따로 있다. 버전 중 가장 최신 버전을 매치 시켜주겠다는 말이 아니다.

		: 출력되는 내용 ) 
			(1) "Using default tag: latest" 
				: 태그명을 명시하지않으면 이 문구가 나온다. (명시하면 안나옴)

			(2) "latest : pulling from library/이미지명" 
				: 해당 이미지를 원격저장소의 library/이미지명 에서 pull 을 받겠다. 

			(3) "이미지레이어다이제스트 : pull complete"
				: 해당 이미지 "레이어"가 성공적으로 다운로드 되었다. 
 					: 이미지레이어 >> 도커 이미지의 "특정" 레이어. 도커 이미지의 일부.
				: 이미지 레이어가 다운로드 될 떄마다 출력된다.
				: docker hub 에 나오는 해당 이미지의 수보다 더 적게 이 문구가 출력될 수도 있는데 , 이는 정상적인거다. 이미 존재하는 레이어일 경우 또 다운받지 않고 재사용하게 되어있기 떄문이다.

 
			(4) "Digest: 이미지다이제스트"
				: 이미지다이제스트 >> sha256기반으로 구해진 해당 도커 이미지 "자체"의 고유식별자
				:다이제스트 값으로도 해당 이미지를 똑같이 다운받을 수 있다 >> "docker image pull 이미지명@sha256:이미지다이제스트값"

			(5) "Status : Downloaded newer image for 이미지명: 태그명"
				: "이미지명: 태그명" 의 다운로드가 성공적으로 완료되었다

			(6) "docker.io/library/이미지명:태그명"
				: 다운로드 완료된 이미지의 URL

	    : ls >> 로컬에 다운로드된 이미지 목록을 확인하겠다
		: 출력되는 내용 ) 	
			1. REPOSITORY
			2. TAG
			3. IMAGE ID << pull 할 때와는 다르게 IMAGE DIGEST 가 나오는게 아님 주의
			4. CREATED
			5. SIZE


	: container >> 컨테이너에 대한 작업을 하겠다 
	    : run >> 특정컨테이너를 실행하겠다
		: 인수 ) 실행하고자 하는 이미지명
		******: 주의 >> 태그까지 명시해야된다. 안그럼 내 의지와 상관 없이 "latest" 가 적용된다.

		: 사실 run 은 container 이란 명령어 없이 바로 "docker run" 만 써도 되긴 하는데, container 라는 하위명령어를 명시하는게 권장된다.
		: 옵션
			(1) 안줌 : 단순 실행시킴
				: 출력결과 ) 딱히 아웃풋이 뭔가 없다 

			(2) -i : interactive. 표준입력(STDIN) 을 열어두어, 사용자로부터 입력을 받을 수 있게 한다.
			(3) -t : tty. 가상터미널을 할당한다. 

		 : 유용한 옵션 세트
			(1) -it : 컨테이너 내부에 들어가고 싶을 때 사용.
				: 의미 >> 가상 터미널에서, 키보드 입력을 컨테이너에게 전달하겠다.
				: 결과 >>
					1. 사용자 이름과 호스트 이름이 바뀐다.
						사용자는 >> root 로
						호스트이름은 >> 컨테이너 ID

	    : ls >> "실행중인" 도커 컨테이너 목록을 확인하겠다.
		: 출력결과 ) 	
			1. CONTAINER ID 
			2. IMAGE
			3. COMMAND
			4. STATUS
			5. PORTS
			6. NAMES 

		: 옵션
			(1) 안줌 : 실행 상태의 컨테이너만 출력됨
			(2) -a : all. 실행 상태, 정지 상태의 컨테이너를 모두 출력




도커의 작동 방식
	1. 도커 클라이언트에서 (이미지를 다운받는) 명령어를 입력 : docker image pull [이미지명:태그명]
	2. 도커 호스트의 데몬이 해당 명령어를 받고 해당 이미지가 존재하는지 확인
		case 1, 도커 호스트에 해당 이미지가 존재하지 않으면, "도커레지스트리"에서 해당 이미지를 다운로드 받음  
			ex ) hello-world 이미지가 다운로드되있지 않은 상황에서 "docker container run hello-world" 의 작동 과정
				1. docker container run hello-world 명령어 입력
					: docker >> docker 패키지를 사용하겠단 기본명령어
					: container >> 컨테이너 대한 작업 하겠다.
					: run >> 컨테이너를 실행하겠단 하위 명령어
					: hello-world >> 컨테이너 이름

				2. 출력됨
					(1) "unalbe to find image 'hello-world:latest' locally" 
						: 로컬에서 hello-world 를 찾을 수 없다. 해당 이미지가 다운로드 안되어있다.
					(2) "latest : pulling from library/hello-world" 
						: 해당 이미지가 다운로드 되어있지 않으니 library/hello-world 에서 pull 을 받겠다. 
					(3) "이미지레이어다이제스트 : pull complete"
					(4) "Digest: 이미지다이제스트"
					(5) "Status : Downloaded newer image for hello-world: latest"
						: hello-world: latest 의 다운로드가 완료되었다


		case 2. 도커 호스트에 해당 이미지가 존재한다면
			ex ) hello-world 이미지가 다운로드되있는 상황에서 "docker container run hello-world" 의 작동 과정
				1. docker container run hello-world 명령어 입력
				2. (따로 뭔가 출력되진 않고) 로컬에 있는 이미지가 실행된다




